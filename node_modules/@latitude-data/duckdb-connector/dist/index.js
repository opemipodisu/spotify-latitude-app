import path from 'path';
import { BaseConnector, ConnectorError } from '@latitude-data/source-manager';
import { emptyMetadata } from '@latitude-data/sql-compiler';
import QueryResult, { DataType } from '@latitude-data/query_result';
import { Database, OPEN_READWRITE, OPEN_READONLY } from 'duckdb-async';

class DuckdbConnector extends BaseConnector {
    client;
    url;
    constructor(options) {
        super(options);
        this.url = options.connectionParams.url || ':memory:';
    }
    end() {
        if (this.client)
            return this.client.close();
        return Promise.resolve();
    }
    resolve(value) {
        return {
            value,
            resolvedAs: '?',
        };
    }
    buildSupportedMethods(buildArgs) {
        const supportedMethods = super.buildSupportedMethods(buildArgs);
        const { context } = buildArgs;
        return {
            ...supportedMethods,
            materialized: {
                requirements: {
                    interpolationPolicy: 'require',
                    interpolationMethod: 'raw',
                    requireStaticArguments: true,
                },
                resolve: async (referencedQuery) => {
                    if (typeof referencedQuery !== 'string') {
                        throw new Error('Invalid query name');
                    }
                    const fullSubQueryPath = referencedQuery.startsWith('/')
                        ? referencedQuery
                        : path.join(path.dirname(context.request.queryPath), referencedQuery);
                    if (context.queriesBeingCompiled.includes(fullSubQueryPath.replace(/.sql$/, ''))) {
                        throw new Error('Query reference to a parent, resulting in cyclic references.');
                    }
                    const refSource = (await this.source.manager.loadFromQuery(fullSubQueryPath));
                    const { config, methods, sqlHash } = await refSource.getMetadataFromQuery(fullSubQueryPath);
                    if (!config.materialize) {
                        throw new Error(`Referenced query is not a materialized. \nYou can materialize it by adding {@config materialized_query = true} in the query content.`);
                    }
                    const unsupportedMethods = ['param', 'runQuery'];
                    const unsupportedMethodsInQuery = Array.from(methods).filter((method) => unsupportedMethods.includes(method));
                    if (unsupportedMethodsInQuery.length > 0) {
                        const unsupportedMethodsStr = unsupportedMethodsInQuery.join(', ');
                        throw new Error(`Referenced query must be static. It can not contain any of the following methods: ${unsupportedMethodsStr}`);
                    }
                    const storage = await this.source.manager.materializeStorage;
                    const materializeUrl = await storage.getUrl({
                        sqlHash,
                        sourcePath: refSource.path,
                        queryName: referencedQuery,
                    });
                    return `read_parquet('${materializeUrl}')`;
                },
                readMetadata: async () => {
                    return emptyMetadata();
                },
            },
        };
    }
    async createClient() {
        this.client = await Database.create(this.url, this.url === ':memory:' ? OPEN_READWRITE : OPEN_READONLY);
    }
    async runQuery(compiledQuery) {
        try {
            if (!this.client)
                await this.createClient();
            const conn = await this.client.connect();
            let results = [];
            if (compiledQuery.resolvedParams.length > 0) {
                const stmt = await conn.prepare(compiledQuery.sql);
                results = await stmt.all(...this.buildQueryParams(compiledQuery.resolvedParams));
                stmt.finalize();
            }
            else {
                results = await conn.all(compiledQuery.sql);
            }
            const rows = results.map((row) => Object.values(row));
            const rowCount = results.length;
            const firstRow = results[0];
            const fields = firstRow
                ? Object.keys(firstRow).map((key) => ({
                    name: key,
                    type: DataType.String,
                }))
                : [];
            return new QueryResult({ fields, rows, rowCount });
        }
        catch (error) {
            throw new ConnectorError(error.message);
        }
    }
    buildQueryParams(params) {
        return params.map((param) => param.value);
    }
}

export { DuckdbConnector as default };
//# sourceMappingURL=index.js.map
