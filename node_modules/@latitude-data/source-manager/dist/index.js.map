{"version":3,"file":"index.js","sources":["../src/types.ts","../src/manager/findSourceConfig.ts","../src/baseConnector/supportedMethods/cast.ts","../src/baseConnector/supportedMethods/interpolate.ts","../src/baseConnector/supportedMethods/param.ts","../src/baseConnector/utils.ts","../src/baseConnector/supportedMethods/ref.ts","../src/baseConnector/supportedMethods/runQuery.ts","../src/baseConnector/supportedMethods/index.ts","../src/baseConnector/index.ts","../src/testConnector/index.ts","../src/baseConnector/connectorFactory.ts","../src/source/index.ts","../src/source/readConfig.ts","../src/materialize/drivers/StorageDriver.ts","../src/materialize/drivers/dummy/DummyDriver.ts","../src/manager/index.ts","../src/materialize/drivers/disk/DiskDriver.ts","../src/materialize/findAndMaterializeQueries.ts","../src/materialize/index.ts"],"sourcesContent":["import { Field, QueryResultArray } from '@latitude-data/query_result'\nimport { Source } from './source'\nexport { CompileError } from '@latitude-data/sql-compiler'\n\nexport type { GetUrlParams } from './materialize/drivers/StorageDriver'\n\nexport enum ConnectorType {\n  Athena = 'athena',\n  Clickhouse = 'clickhouse',\n  Duckdb = 'duckdb',\n  Postgres = 'postgres',\n  Bigquery = 'bigquery',\n  Mysql = 'mysql',\n  Redshift = 'redshift',\n  Snowflake = 'snowflake',\n  Trino = 'trino',\n  Sqlite = 'sqlite',\n  Mssql = 'mssql',\n  Databricks = 'databricks',\n  Test = 'test', // Used for testing purposes\n  TestInternal = 'internal_test', // Used for testing inside this package purposes\n}\n\nexport type QueryConfig = {\n  ttl?: number\n  materialize?: boolean\n}\n\nexport type QueryParams = {\n  [key: string]: unknown\n}\n\nexport type QueryRequest = {\n  queryPath: string\n  params?: QueryParams\n}\nexport type ResolvedParam = {\n  value: unknown\n  resolvedAs: string\n}\nexport type CompileQueryRequest = QueryRequest & { sql: string }\nexport type RanQueries = Record<string, QueryResultArray>\nexport type CompilationContext = {\n  // Requested query\n  request: CompileQueryRequest\n  // Parameters used in the query\n  accessedParams: QueryParams\n  // Parameters resolved by the connector, in order of appearance\n  resolvedParams: ResolvedParam[]\n  // Cache of already ran queries\n  ranQueries: RanQueries\n  // Used to detect cyclic references\n  queriesBeingCompiled: string[]\n}\n\nexport type BuildSupportedMethodsArgs = {\n  source: Source\n  context: CompilationContext\n}\n\nexport type CompiledQuery = {\n  sql: string\n  resolvedParams: ResolvedParam[]\n  accessedParams: QueryParams\n}\n\nexport class ConnectorError extends Error {}\nexport class ConnectionError extends ConnectorError {}\nexport class QueryError extends ConnectorError {}\n\nexport class NotFoundError extends Error {}\n\nexport class QueryNotFoundError extends NotFoundError {}\nexport class SourceFileNotFoundError extends NotFoundError {}\n\nexport interface SourceSchema {\n  type: ConnectorType\n  details?: Record<string, unknown>\n  config?: QueryConfig\n}\n\nexport type BatchedRow = Record<string, unknown>\nexport type BatchResponse = {\n  rows: BatchedRow[]\n  fields: Field[]\n  lastBatch: boolean\n}\nexport type BatchedQueryOptions = {\n  batchSize: number\n  onBatch: (_r: BatchResponse) => Promise<void>\n}\n\n// Parquet logical types\n// https://github.com/LibertyDSNP/parquetjs?tab=readme-ov-file#list-of-supported-types--encodings\nexport enum ParquetLogicalType {\n  BOOLEAN = 'BOOLEAN',\n  INT32 = 'INT32',\n  INT64 = 'INT64',\n  INT96 = 'INT96',\n  FLOAT = 'FLOAT',\n  DOUBLE = 'DOUBLE',\n  BYTE_ARRAY = 'BYTE_ARRAY',\n  FIXED_LEN_BYTE_ARRAY = 'FIXED_LEN_BYTE_ARRAY',\n  UTF8 = 'UTF8',\n  ENUM = 'ENUM',\n  DATE = 'DATE',\n  TIME_MILLIS = 'TIME_MILLIS',\n  TIMESTAMP_MILLIS = 'TIMESTAMP_MILLIS',\n  TIMESTAMP_MICROS = 'TIMESTAMP_MICROS',\n  TIME_MICROS = 'TIME_MICROS',\n  UINT_8 = 'UINT_8',\n  UINT_16 = 'UINT_16',\n  UINT_32 = 'UINT_32',\n  UINT_64 = 'UINT_64',\n  INT_8 = 'INT_8',\n  INT_16 = 'INT_16',\n  INT_32 = 'INT_32',\n  INT_64 = 'INT_64',\n  JSON = 'JSON',\n  BSON = 'BSON',\n  INTERVAL = 'INTERVAL',\n}\n","import * as fs from 'fs'\nimport path from 'path'\nimport { SourceFileNotFoundError, QueryNotFoundError } from '@/types'\n\nexport default function findSourceConfigFromQuery({\n  query,\n  queriesDir,\n}: {\n  query: string\n  queriesDir: string\n}) {\n  const fullPath = path.join(\n    queriesDir,\n    query.endsWith('.sql') ? query : `${query}.sql`,\n  )\n\n  if (!fs.existsSync(fullPath)) {\n    throw new QueryNotFoundError(`Query file not found at ${fullPath}`)\n  }\n\n  try {\n    fs.accessSync(fullPath)\n  } catch (e) {\n    throw new QueryNotFoundError(`Query file not found at ${fullPath}`)\n  }\n\n  // Start from the directory of the .sql file and iterate upwards.\n  let currentDir = path.dirname(fullPath)\n\n  while (currentDir.includes(queriesDir)) {\n    // Stop if the root directory is reached\n    // Try to find a .yml file in the current directory\n    const files = fs.readdirSync(currentDir)\n    const ymlFile = files?.find(\n      (file) => file.endsWith('.yml') || file.endsWith('.yaml'),\n    )\n\n    if (ymlFile) {\n      // Assume a YML file is the source configuration file\n      return path.join(currentDir, ymlFile)\n    }\n\n    // Move up one directory\n    currentDir = path.dirname(currentDir)\n  }\n\n  throw new SourceFileNotFoundError(`Source file not found at ${fullPath}`)\n}\n","import { BuildSupportedMethodsArgs } from '@/types'\nimport {\n  emptyMetadata,\n  type SupportedMethod,\n} from '@latitude-data/sql-compiler'\n\nconst buildCastMethod = (_: BuildSupportedMethodsArgs): SupportedMethod => ({\n  requirements: {\n    interpolationPolicy: 'allow', // Results can be interpolated\n    interpolationMethod: 'parameterize', // When interpolating, use parameterization\n    requireStaticArguments: false, // Can be used with variables or logic expressions\n  },\n\n  resolve: async (value: unknown, type: string) => {\n    if (!(type in CAST_METHODS)) {\n      throw new Error(\n        `Unsupported cast type: '${type}'. Supported types are: ${Object.keys(\n          CAST_METHODS,\n        ).join(', ')}`,\n      )\n    }\n    return CAST_METHODS[type]!(value)\n  },\n\n  readMetadata: async () => {\n    return emptyMetadata()\n  },\n})\n\nconst CAST_METHODS: {\n  [type: string]: (value: any) => unknown\n} = {\n  string: (value) => String(value),\n  text: (value) => String(value),\n  int: (value) => parseInt(value),\n  float: (value) => parseFloat(value),\n  number: (value) => Number(value),\n  bool: (value) => Boolean(value),\n  boolean: (value) => Boolean(value),\n  date: (value) => new Date(value),\n}\n\nexport default buildCastMethod\n","import { BuildSupportedMethodsArgs } from '@/types'\nimport {\n  emptyMetadata,\n  type SupportedMethod,\n} from '@latitude-data/sql-compiler'\n\nconst buildInterpolateMethod = (\n  _: BuildSupportedMethodsArgs,\n): SupportedMethod => ({\n  requirements: {\n    interpolationPolicy: 'require', // Cannot be used inside a logic block\n    interpolationMethod: 'raw', // When interpolating, will just inject the value directly into the query\n    requireStaticArguments: false, // Can be used with variables or logic expressions\n  },\n\n  resolve: async (value: unknown) => {\n    return String(value)\n  },\n\n  readMetadata: async () => {\n    return emptyMetadata()\n  },\n})\n\nexport default buildInterpolateMethod\n","import { BuildSupportedMethodsArgs } from '@/types'\nimport {\n  emptyMetadata,\n  type SupportedMethod,\n} from '@latitude-data/sql-compiler'\n\nconst buildParamMethod = ({\n  context,\n}: BuildSupportedMethodsArgs): SupportedMethod => ({\n  requirements: {\n    interpolationPolicy: 'allow', // Results can be interpolated\n    interpolationMethod: 'parameterize', // When interpolating, use parameterization\n    requireStaticArguments: false, // Can be used with variables or logic expressions\n  },\n\n  resolve: async (name: string, defaultValue?: unknown) => {\n    const requestParams = context.request.params ?? {}\n    if (typeof name !== 'string') throw new Error('Invalid parameter name')\n    if (!(name in requestParams) && defaultValue === undefined) {\n      throw new Error(`Missing parameter '${name}' in request`)\n    }\n    if (name in requestParams) {\n      context.accessedParams[name] = requestParams[name]\n    }\n    return name in requestParams ? requestParams[name] : defaultValue\n  },\n\n  readMetadata: async () => {\n    return emptyMetadata()\n  },\n})\n\nexport default buildParamMethod\n","import path from 'path'\n\nexport function getFullQueryPath({\n  referencedQueryPath,\n  currentQueryPath,\n}: {\n  referencedQueryPath: string\n  currentQueryPath: string\n}): string {\n  return referencedQueryPath.startsWith('/')\n    ? referencedQueryPath\n    : path.join(path.dirname(currentQueryPath), referencedQueryPath)\n}\n\nexport function assertNoCyclicReferences(\n  queryPath: string,\n  queriesBeingCompiled: string[],\n): void {\n  const queryName = queryPath.replace(/.sql$/, '')\n\n  if (!queriesBeingCompiled.includes(queryName)) return\n\n  throw new Error(\n    'Query reference to a parent, resulting in cyclic references.',\n  )\n}\n","import { BuildSupportedMethodsArgs } from '@/types'\nimport {\n  emptyMetadata,\n  type SupportedMethod,\n} from '@latitude-data/sql-compiler'\nimport { assertNoCyclicReferences, getFullQueryPath } from '../utils'\nimport { createHash } from 'crypto'\n\nconst buildRefMethod = ({\n  source,\n  context,\n}: BuildSupportedMethodsArgs): SupportedMethod => ({\n  requirements: {\n    interpolationPolicy: 'require', // Cannot be used inside a logic block\n    interpolationMethod: 'raw', // When interpolating, will just inject the returned value directly into the query\n    requireStaticArguments: true, // Can only use static arguments\n  },\n\n  resolve: async (referencedQuery: string) => {\n    if (typeof referencedQuery !== 'string') {\n      throw new Error('Invalid reference query')\n    }\n\n    const fullSubQueryPath = getFullQueryPath({\n      referencedQueryPath: referencedQuery,\n      currentQueryPath: context.request.queryPath,\n    })\n\n    assertNoCyclicReferences(fullSubQueryPath, context.queriesBeingCompiled)\n\n    const refSource = await source.manager.loadFromQuery(fullSubQueryPath)\n    if (refSource !== source) {\n      throw new Error('Query reference to a different source')\n    }\n\n    const refRequest = {\n      queryPath: fullSubQueryPath,\n      params: context.request.params,\n    }\n    const { request: _, ...refContext } = context // Everything except request is passed to the subquery context\n    const compiledSubQuery = await source.compileQuery(refRequest, refContext)\n\n    return `(${compiledSubQuery.sql})`\n  },\n\n  readMetadata: async (args?: unknown[]) => {\n    const [referencedQuery] = args!\n    const fullSubQueryPath = getFullQueryPath({\n      referencedQueryPath: referencedQuery as string,\n      currentQueryPath: context.request.queryPath,\n    })\n    const { rawSql, ...rest } =\n      await source.getMetadataFromQuery(fullSubQueryPath)\n    const sqlHash = createHash('sha256').update(rawSql!).digest('hex')\n    return {\n      ...rest,\n      config: emptyMetadata().config, // The config from the referenced query is not relevant for the parent query\n      sqlHash,\n    }\n  },\n})\n\nexport default buildRefMethod\n","import { BuildSupportedMethodsArgs } from '@/types'\nimport {\n  emptyMetadata,\n  type SupportedMethod,\n} from '@latitude-data/sql-compiler'\nimport { assertNoCyclicReferences, getFullQueryPath } from '../utils'\n\nconst buildRunQueryMethod = ({\n  source,\n  context,\n}: BuildSupportedMethodsArgs): SupportedMethod => ({\n  requirements: {\n    interpolationPolicy: 'disallow', // Cannot be directly interpolated\n    interpolationMethod: 'parameterize', // When interpolating, use parameterization\n    requireStaticArguments: false, // Can only use static arguments\n  },\n\n  resolve: async (referencedQuery: string) => {\n    if (typeof referencedQuery !== 'string') {\n      throw new Error('Invalid reference query')\n    }\n\n    const fullSubQueryPath = getFullQueryPath({\n      referencedQueryPath: referencedQuery,\n      currentQueryPath: context.request.queryPath,\n    })\n\n    if (fullSubQueryPath in context.ranQueries) {\n      return context.ranQueries[fullSubQueryPath]\n    }\n\n    assertNoCyclicReferences(fullSubQueryPath, context.queriesBeingCompiled)\n\n    const refSource = await source.manager.loadFromQuery(fullSubQueryPath)\n\n    const refRequest = {\n      queryPath: fullSubQueryPath,\n      params: context.request.params,\n    }\n    const refContext = {\n      accessedParams: context.accessedParams,\n      resolvedParams: [], // Subquery must not access nor modify the parent query's resolved params\n      ranQueries: context.ranQueries,\n      queriesBeingCompiled: context.queriesBeingCompiled,\n    }\n    const compiledSubQuery = await refSource.compileQuery(\n      refRequest,\n      refContext,\n    )\n    const results = await refSource\n      .runCompiledQuery(compiledSubQuery)\n      .then((res) => res.toArray())\n    context.ranQueries[fullSubQueryPath] = results\n\n    return results\n  },\n\n  readMetadata: async () => {\n    return emptyMetadata()\n  },\n})\n\nexport default buildRunQueryMethod\n","import { type SupportedMethod } from '@latitude-data/sql-compiler'\nimport { BuildSupportedMethodsArgs } from '@/types'\n\nimport { default as buildCast } from './cast'\nimport { default as buildInterpolate } from './interpolate'\nimport { default as buildParam } from './param'\nimport { default as buildRef } from './ref'\nimport { default as buildRunQuery } from './runQuery'\n\nexport default function buildSupportedMethods(\n  args: BuildSupportedMethodsArgs,\n): Record<string, SupportedMethod> {\n  return {\n    interpolate: buildInterpolate(args),\n    param: buildParam(args),\n    ref: buildRef(args),\n    runQuery: buildRunQuery(args),\n    cast: buildCast(args),\n  }\n}\n","import {\n  compile,\n  QueryMetadata,\n  readMetadata,\n  SupportedMethod,\n  type CompileError,\n} from '@latitude-data/sql-compiler'\nimport type QueryResult from '@latitude-data/query_result'\n\nimport { Source } from '@/source'\nimport type {\n  ResolvedParam,\n  CompiledQuery,\n  CompilationContext,\n  BuildSupportedMethodsArgs,\n  CompileQueryRequest,\n  BatchedQueryOptions,\n  QueryConfig,\n} from '@/types'\nimport buildSupportedMethods from './supportedMethods'\n\nexport type ConnectorAttributes = {\n  [key: string]: unknown\n}\nexport { CompileError }\nexport type ConnectorOptions<P extends ConnectorAttributes> = {\n  source: Source\n  connectionParams: P\n}\n\nexport abstract class BaseConnector<P extends ConnectorAttributes = {}> {\n  protected source: Source\n\n  constructor({ source }: ConnectorOptions<P>) {\n    this.source = source\n  }\n\n  /**\n   * While compiling the query, the connector will call this method to resolve the\n   * parameterised string for a variable. The index is the position of this variable\n   * in the array of ResolvedParams that will be passed to the runQuery method.\n   */\n  protected abstract resolve(value: unknown, index: number): ResolvedParam\n\n  /**\n   * Perform the actual query execution on the data source.\n   */\n  protected abstract runQuery(request: CompiledQuery): Promise<QueryResult>\n\n  /**\n   * The connector is able to perform streaming (batching) of the results\n   * of a query. If the connector does not define this method it will throw\n   */\n  async batchQuery(_c: CompiledQuery, _o: BatchedQueryOptions): Promise<void> {\n    throw new Error('Batching not supported')\n  }\n\n  /**\n   * Close the connection to the data source.\n   * This method must only be called once all queries have been executed and the\n   * connector instance is no longer needed.\n   */\n  async end(): Promise<void> {}\n\n  /**\n   * Compile the given query. This method returns the compiled SQL, resolved parameters,\n   * and information about the compilation process.\n   */\n  async compileQuery(context: CompilationContext): Promise<CompiledQuery> {\n    const { request, resolvedParams, accessedParams, queriesBeingCompiled } =\n      context\n    queriesBeingCompiled.push(request.queryPath)\n\n    const resolveFn = async (value: unknown): Promise<string> => {\n      const resolved = this.resolve(value, resolvedParams.length)\n      resolvedParams.push(resolved)\n      return resolved.resolvedAs\n    }\n\n    const supportedMethods = this.buildSupportedMethods({\n      source: this.source,\n      context,\n    })\n\n    const compiledSql = await compile({\n      supportedMethods,\n      query: request.sql,\n      resolveFn,\n    })\n\n    // NOTE: To avoid compiling subqueries that have already\n    // been compiled in the current call stack.\n    queriesBeingCompiled.pop()\n\n    return {\n      sql: compiledSql,\n      resolvedParams,\n      accessedParams,\n    }\n  }\n\n  /**\n   * Parses the query and returns the configuration defined and methods used.\n   * This definition is static, and only depends on the contents of the query\n   * itself.\n   */\n  readMetadata(\n    request: CompileQueryRequest,\n  ): Promise<QueryMetadata<QueryConfig>> {\n    // The supported methods object is only needed for their keys, but the actual\n    // function implementations are not used, since they won't be called in this\n    // process. Since some functions require context-specific information just to\n    // be defined, they are mocked in this case.\n    const supportedMethods = this.buildSupportedMethods({\n      context: {\n        request,\n        accessedParams: {},\n        resolvedParams: [],\n        ranQueries: {},\n        queriesBeingCompiled: [],\n      },\n      source: this.source,\n    })\n\n    return readMetadata({\n      query: request.sql,\n      supportedMethods,\n    })\n  }\n\n  runCompiled(request: CompiledQuery): Promise<QueryResult> {\n    return this.runQuery(request)\n  }\n\n  protected buildSupportedMethods(\n    buildArgs: BuildSupportedMethodsArgs,\n  ): Record<string, SupportedMethod> {\n    return buildSupportedMethods(buildArgs)\n  }\n}\n","import { BaseConnector, ConnectorOptions } from '@/baseConnector'\nimport {\n  BatchedQueryOptions,\n  CompiledQuery,\n  ConnectionError,\n  ConnectorError,\n  ResolvedParam,\n} from '@/types'\nimport QueryResult, { DataType } from '@latitude-data/query_result'\n\nexport type ConnectionParams = {\n  fail?: string | false // Connection will fail with the given message\n  onResolve?: (value: unknown, resolvedParam: ResolvedParam) => void\n  onRunQuery?: (\n    compiledQuery: CompiledQuery,\n    result?: QueryResult,\n    error?: Error,\n  ) => void\n}\n\n/**\n * This is a mock connector that can be used for testing purposes.\n * It does not connect to any database and returns a result based on\n * the input query.\n *\n * Each line in the query will represent a new row in the result, as\n * a 'value' field.\n * Resolved values are shown in the result as `[[value]]`\n *\n * A line can also start with one of the following keywords to define\n * different behaviors:\n * - `FAIL <message>` will throw an error with the given message.\n * - `SLEEP <ms>` will wait for the given number of milliseconds.\n */\nexport default class TestConnector extends BaseConnector<ConnectionParams> {\n  private onResolve?: (value: unknown, resolvedParam: ResolvedParam) => void\n  private onRunQuery?: (\n    compiledQuery: CompiledQuery,\n    result?: QueryResult,\n    error?: Error,\n  ) => void\n\n  constructor(options: ConnectorOptions<ConnectionParams>) {\n    super(options)\n    const connectionParams = options.connectionParams\n\n    if (connectionParams?.fail) {\n      throw new ConnectionError(connectionParams.fail)\n    }\n    this.onResolve = connectionParams?.onResolve\n    this.onRunQuery = connectionParams?.onRunQuery\n  }\n\n  resolve(value: unknown): ResolvedParam {\n    const resolvedParam = {\n      value,\n      resolvedAs: `[[${value}]]`,\n    }\n    this?.onResolve?.(value, resolvedParam)\n    return resolvedParam\n  }\n\n  async batchQuery(\n    compiledQuery: CompiledQuery,\n    options: BatchedQueryOptions,\n  ): Promise<void> {\n    return Promise.reject(\n      new Error(`\n        batchQuery not implemented for TestConnector\n        Mock it in your tests\n        CompiledQuery: ${JSON.stringify(compiledQuery)}\n        batchOptions: ${JSON.stringify(options)}\n      `),\n    )\n  }\n\n  async runQuery(compiledQuery: CompiledQuery): Promise<QueryResult> {\n    const lines = compiledQuery.sql.split('\\n')\n    const rows = []\n    const commands = ['FAIL', 'SLEEP']\n    for (const line of lines) {\n      const command = commands.find((c) => line.trim().startsWith(c))\n      const content = line\n        .trim()\n        .slice(command?.length)\n        .trim()\n\n      if (command === 'FAIL') {\n        this?.onRunQuery?.(\n          compiledQuery,\n          undefined,\n          new ConnectorError(content),\n        )\n        throw new ConnectorError(content)\n      }\n\n      if (command === 'SLEEP') {\n        const time = parseInt(content, 10)\n        await new Promise((resolve) => setTimeout(resolve, time))\n        continue\n      }\n\n      rows.push(content)\n    }\n\n    const result = new QueryResult({\n      fields: [{ name: 'value', type: DataType.String }],\n      rows: rows.map((value) => [value]),\n      rowCount: rows.length,\n    })\n\n    if (this.onRunQuery) this.onRunQuery(compiledQuery, result)\n    return result\n  }\n}\n","import {\n  BaseConnector,\n  ConnectorAttributes,\n  ConnectorOptions,\n} from '@/baseConnector'\nimport { ConnectorType } from '@/types'\nimport TestConnector from '@/testConnector'\n\nconst CONNECTOR_PACKAGES = {\n  [ConnectorType.Postgres]: 'postgresql-connector',\n  [ConnectorType.Redshift]: 'postgresql-connector',\n  [ConnectorType.Clickhouse]: 'clickhouse-connector',\n  [ConnectorType.Bigquery]: 'bigquery-connector',\n  [ConnectorType.Mysql]: 'mysql-connector',\n  [ConnectorType.Snowflake]: 'snowflake-connector',\n  [ConnectorType.Athena]: 'athena-connector',\n  [ConnectorType.Trino]: 'trino-connector',\n  [ConnectorType.Duckdb]: 'duckdb-connector',\n  [ConnectorType.Sqlite]: 'sqlite-connector',\n  [ConnectorType.Mssql]: 'mssql-connector',\n  [ConnectorType.Databricks]: 'databricks-connector',\n  [ConnectorType.Test]: 'test-connector',\n}\n\nclass ConnectorNotInstalledError extends Error {\n  constructor(pkgName: string) {\n    const message = `Module ${pkgName} is not a valid Latitude connector. Please make sure you have the correct package installed in your project by running 'npm install ${pkgName}'`\n    super(message)\n  }\n}\nclass ConnectorWithoutDefaultExportError extends Error {\n  constructor(pkgName: string) {\n    const message = `Module ${pkgName} does not have a default export.`\n    super(message)\n  }\n}\n\nasync function importConnector(\n  packageName: string,\n): Promise<\n  new (_args: ConnectorOptions<ConnectorAttributes>) => BaseConnector\n> {\n  try {\n    const module = await import(/* @vite-ignore */ packageName)\n    const ConnectorClass = module.default\n\n    if (\n      typeof ConnectorClass === 'function' &&\n      ConnectorClass.prototype.constructor\n    ) {\n      return ConnectorClass\n    } else {\n      throw new ConnectorWithoutDefaultExportError(packageName)\n    }\n  } catch (error) {\n    if (error instanceof ConnectorWithoutDefaultExportError) {\n      throw error\n    }\n    throw new ConnectorNotInstalledError(packageName)\n  }\n}\n\nexport class InvalidConnectorType extends Error {}\n\nexport function getConnectorPackage(type: ConnectorType) {\n  if (type === ConnectorType.TestInternal) return null\n\n  if (!(type in CONNECTOR_PACKAGES)) {\n    throw new InvalidConnectorType(`Unsupported connector type: ${type}`)\n  }\n  const pkgName = CONNECTOR_PACKAGES[type]\n\n  return `@latitude-data/${pkgName}`\n}\n\nexport default async function createConnectorFactory({\n  type,\n  connectorOptions,\n}: {\n  type: ConnectorType\n  connectorOptions: ConnectorOptions<ConnectorAttributes>\n}): Promise<BaseConnector> {\n  const packageName = getConnectorPackage(type)\n  const ConnectorClass = !packageName\n    ? TestConnector // If no package is found, use the test connector\n    : await importConnector(packageName)\n\n  return new ConnectorClass(connectorOptions)\n}\n","import 'dotenv/config'\nimport * as fs from 'fs'\nimport path from 'path'\n\nimport type QueryResult from '@latitude-data/query_result'\nimport { BaseConnector } from '@/baseConnector'\nimport createConnectorFactory, {\n  getConnectorPackage,\n} from '@/baseConnector/connectorFactory'\nimport {\n  BatchedQueryOptions,\n  CompilationContext,\n  ConnectionError,\n  ConnectorType,\n} from '@/types'\nimport { CompiledQuery, QueryConfig, QueryRequest, SourceSchema } from '@/types'\nimport SourceManager from '@/manager'\nimport { QueryMetadata } from '@latitude-data/sql-compiler'\n\nexport function buildDefaultContext(): Omit<CompilationContext, 'request'> {\n  return {\n    accessedParams: {},\n    resolvedParams: [],\n    ranQueries: {},\n    queriesBeingCompiled: [],\n  }\n}\n\nexport class Source {\n  private _schema: SourceSchema\n  private _connector?: BaseConnector\n  readonly path: string\n  readonly manager: SourceManager\n\n  constructor({\n    path,\n    schema,\n    sourceManager,\n    connector,\n  }: {\n    path: string\n    schema: SourceSchema\n    sourceManager: SourceManager\n    connector?: BaseConnector\n  }) {\n    this.path = path\n    this._schema = schema\n    this.manager = sourceManager\n    this._connector = connector\n  }\n\n  get config(): QueryConfig {\n    return this._schema?.config ?? {}\n  }\n\n  get type(): SourceSchema['type'] {\n    return this._schema.type\n  }\n\n  get connectionParams() {\n    return this._schema.details ?? {}\n  }\n\n  get connectorPackageName(): string {\n    const pkgName = getConnectorPackage(this.type as ConnectorType)\n    return pkgName ?? ConnectorType.TestInternal\n  }\n\n  async endConnection(): Promise<void> {\n    if (!this._connector) return\n    await this._connector.end()\n    this._connector = undefined\n  }\n\n  async getMetadataFromQuery(queryPath: string): Promise<QueryMetadata> {\n    const sql = await this.getSql(queryPath)\n    const connector = await this.connector()\n    const request = { queryPath, sql, params: {} }\n    const { config: queryConfig, ...rest } =\n      await connector.readMetadata(request)\n    return {\n      config: {\n        ...this.config,\n        ...queryConfig,\n      },\n      ...rest,\n    }\n  }\n\n  async compileQuery(\n    { queryPath, params }: QueryRequest,\n    context?: Omit<CompilationContext, 'request'>,\n  ): Promise<CompiledQuery> {\n    const sql = await this.getSql(queryPath)\n    const connector = await this.connector()\n\n    const defaultContext = buildDefaultContext()\n    const fullContext = {\n      ...defaultContext,\n      ...context,\n      request: { queryPath, sql, params: params ?? {} },\n    }\n\n    return await connector.compileQuery(fullContext)\n  }\n\n  async runCompiledQuery(compiledQuery: CompiledQuery): Promise<QueryResult> {\n    const connector = await this.connector()\n    return await connector.runCompiled(compiledQuery)\n  }\n\n  async batchQuery(\n    compiledQuery: CompiledQuery,\n    options: BatchedQueryOptions,\n  ): Promise<void> {\n    const connector = await this.connector()\n    return connector.batchQuery(compiledQuery, options)\n  }\n\n  private async connector(): Promise<BaseConnector> {\n    if (!this._connector) {\n      this._connector = await createConnectorFactory({\n        type: this.type,\n        connectorOptions: {\n          source: this,\n          connectionParams: this.connectionParams,\n        },\n      })\n    }\n\n    return this._connector\n  }\n\n  private async getSql(queryPath: string): Promise<string> {\n    const querySource = await this.manager.loadFromQuery(queryPath)\n\n    if (this !== querySource) {\n      throw new ConnectionError(\n        `Query path \"${queryPath}\" is not in source \"${this.path}\"`,\n      )\n    }\n\n    const cleanPath = queryPath.replace(/^\\//, '')\n    const sqlPath = path.resolve(\n      this.manager.queriesDir,\n      cleanPath.endsWith('.sql') ? cleanPath : `${cleanPath}.sql`,\n    )\n\n    return fs.readFileSync(sqlPath, 'utf8')\n  }\n}\n","import fs from 'fs'\nimport yaml from 'yaml'\nimport { SourceSchema, SourceFileNotFoundError } from '@/types'\n\nexport class InvalidSourceConfigError extends Error {\n  constructor(message: string) {\n    super(message)\n    this.name = 'InvalidSourceConfigError'\n  }\n}\n\nexport default function readSourceConfig(sourcePath: string): SourceSchema {\n  if (!fs.existsSync(sourcePath)) {\n    throw new SourceFileNotFoundError(`Source file not found at ${sourcePath}`)\n  }\n\n  const file = fs.readFileSync(sourcePath, 'utf8')\n  const config = yaml.parse(file, (_, value) => {\n    // if key starts with 'LATITUDE__', replace it with the environment variable\n    if (typeof value === 'string' && value.startsWith('LATITUDE__')) {\n      if (process.env[value]) return process.env[value]\n\n      throw new Error(`\n      Invalid configuration. Environment variable ${value} was not found in the environment. You can review how to set up secret source credentials in the documentation: https://docs.latitude.so/sources/credentials\n      `)\n    } else {\n      return value\n    }\n  })\n\n  // Validation requirements\n  if (!config?.type) {\n    throw new InvalidSourceConfigError(`Missing 'type' in configuration`)\n  }\n\n  if (typeof config.type !== 'string') {\n    throw new InvalidSourceConfigError(`Invalid 'type' in configuration`)\n  }\n\n  return config\n}\n","import SourceManager from '@/manager'\nimport { ParquetLogicalType, QueryRequest } from '@/types'\nimport { DataType, Field } from '@latitude-data/query_result'\nimport { createHash } from 'crypto'\n\nimport { ParquetWriter, ParquetSchema } from '@dsnp/parquetjs'\nimport { FieldDefinition, ParquetType } from '@dsnp/parquetjs/dist/lib/declare'\n\nexport type GetUrlParams = {\n  sqlHash: string\n  queryName: string\n  sourcePath: string\n  ignoreMissingFile?: boolean\n}\nexport type ResolveUrlParams = GetUrlParams & {\n  filename: string\n  ignoreMissingFile?: boolean\n}\nexport class MaterializedFileNotFoundError extends Error {}\n\nfunction mapDataTypeToParquet(dataType: DataType): ParquetType {\n  switch (dataType) {\n    case DataType.Boolean:\n      return ParquetLogicalType.BOOLEAN\n\n    case DataType.Datetime:\n      return ParquetLogicalType.TIMESTAMP_MICROS\n\n    case DataType.Integer:\n      // TODO: review this decision. I faced an issue with an int8 column\n      // in postgresql which is a BigInt. This library does not support it.\n      // it breaks saying:\n      //   Cannot convert a BigInt value to a number ðŸ’¥\n      // If we put here INT64 it works but not sure is the best approach.\n      return ParquetLogicalType.INT32\n\n    case DataType.Float:\n      return ParquetLogicalType.FLOAT\n\n    case DataType.String:\n      return ParquetLogicalType.UTF8\n\n    default:\n      return ParquetLogicalType.BYTE_ARRAY\n  }\n}\n\nconst ROW_GROUP_SIZE = 4096 // PARQUET BATCH WRITE\ntype Result = { filePath: string; queryRows: number }\nexport type WriteParquetParams = QueryRequest & {\n  batchSize?: number\n  onDebug?: (_p: { memoryUsageInMb: string }) => void\n}\n\n/**\n * In order to hash a SQL query, we need to know the source path\n * it came from. This way we ensure the path is unique even\n * if two sources share the same query.\n */\nexport abstract class StorageDriver {\n  private manager: SourceManager\n\n  constructor({ manager }: { manager: SourceManager }) {\n    this.manager = manager\n  }\n\n  abstract get basePath(): string\n\n  async writeParquet({\n    queryPath,\n    params,\n    batchSize,\n    onDebug,\n  }: WriteParquetParams) {\n    let writer: ParquetWriter\n    const source = await this.manager.loadFromQuery(queryPath)\n    const { config, sqlHash } = await source.getMetadataFromQuery(queryPath)\n\n    if (!config.materialize) {\n      throw new Error('Query is not configured as materialized')\n    }\n\n    const compiled = await source.compileQuery({ queryPath, params })\n\n    let currentHeap = 0\n    return new Promise<Result>((resolve) => {\n      let filePath: string\n      let queryRows = 0\n\n      const size = batchSize ?? 1000\n      source.batchQuery(compiled, {\n        batchSize: size,\n        onBatch: async (batch) => {\n          if (!writer) {\n            const schema = this.buildParquetSchema(batch.fields)\n            filePath = await this.getUrl({\n              sqlHash: sqlHash!,\n              queryName: queryPath,\n              sourcePath: source.path,\n              ignoreMissingFile: true,\n            })\n\n            writer = await ParquetWriter.openFile(schema, filePath, {\n              rowGroupSize: size > ROW_GROUP_SIZE ? size : ROW_GROUP_SIZE,\n            })\n          }\n\n          for (const row of batch.rows) {\n            if (onDebug) {\n              let heapUsed = process.memoryUsage().heapUsed\n\n              if (heapUsed < currentHeap) {\n                onDebug({\n                  memoryUsageInMb: `${(currentHeap / 1024 / 1024).toFixed(\n                    2,\n                  )} MB`,\n                })\n              }\n\n              currentHeap = heapUsed\n            }\n\n            try {\n              await writer.appendRow(row)\n            } catch {\n              // If for some reason a row writing fails we don't want\n              // to break the process.\n            }\n          }\n          queryRows += batch.rows.length\n\n          if (batch.lastBatch) {\n            await writer.close()\n            resolve({ filePath, queryRows })\n          }\n        },\n      })\n    })\n  }\n\n  getUrl(args: GetUrlParams): Promise<string> {\n    const name = StorageDriver.hashName(args)\n    const filename = `${name}.parquet`\n\n    return this.resolveUrl({ ...args, filename })\n  }\n\n  /**\n   * It's a Promise because other adapters can be async\n   */\n  abstract resolveUrl({ filename }: ResolveUrlParams): Promise<string>\n\n  static hashName({ sqlHash, sourcePath }: GetUrlParams) {\n    const hash = createHash('sha256')\n    hash.update(sqlHash)\n    hash.update(sourcePath)\n    return hash.digest('hex')\n  }\n\n  private buildParquetSchema(fields: Field[]) {\n    const columns = fields.reduce(\n      (schema, field) => {\n        const type = mapDataTypeToParquet(field.type)\n        schema[field.name] = {\n          type,\n          optional: true,\n          compression: 'SNAPPY',\n        }\n        return schema\n      },\n      {} as { [key: string]: FieldDefinition },\n    )\n\n    return new ParquetSchema(columns)\n  }\n}\n","import SourceManager from '@/manager'\nimport {\n  GetUrlParams,\n  ResolveUrlParams,\n  StorageDriver,\n} from '@/materialize/drivers/StorageDriver'\n\nexport default class DummyDriver extends StorageDriver {\n  constructor({ manager }: { manager: SourceManager }) {\n    super({ manager })\n  }\n\n  get basePath(): string {\n    return '/dummy-base-path'\n  }\n  getUrl(args: GetUrlParams): Promise<string> {\n    return this.resolveUrl({\n      ...args,\n      filename: `ENCRYPTED[${args.sqlHash}].parquet`,\n    })\n  }\n\n  resolveUrl({ filename }: ResolveUrlParams): Promise<string> {\n    return Promise.resolve(filename)\n  }\n}\n","import 'dotenv/config'\nimport * as fs from 'fs'\nimport path from 'path'\nimport findSourceConfigFromQuery from './findSourceConfig'\nimport { QueryNotFoundError, SourceFileNotFoundError } from '@/types'\nimport { Source } from '@/source'\nimport readSourceConfig from '@/source/readConfig'\nimport { StorageDriver } from '@/materialize/drivers/StorageDriver'\nimport DummyDriver from '@/materialize/drivers/dummy/DummyDriver'\nimport { DriverConfig, StorageKlass, StorageType } from '@/materialize'\n\nexport default class SourceManager {\n  private instances: Record<string, Source> = {}\n  readonly materializeStorage: StorageDriver\n  readonly queriesDir: string\n\n  constructor(\n    queriesDir: string,\n    options: {\n      materialize?: {\n        Klass: StorageKlass\n        config: DriverConfig<StorageType>\n      }\n    } = {},\n  ) {\n    this.queriesDir = queriesDir\n    const materializeKlass = options.materialize?.Klass ?? DummyDriver\n    const commonConfig = { manager: this }\n    const config = options.materialize?.config\n    this.materializeStorage = config\n      ? new materializeKlass({ ...config, ...commonConfig })\n      : new DummyDriver(commonConfig)\n  }\n\n  /**\n   * Finds the source configuration file in the given path and loads it\n   * @param path - The path to any file in the source directory. This could be the source configuration file itself or any other query in the directory.\n   */\n  async loadFromQuery(query: string): Promise<Source> {\n    const filePath = path.join(\n      this.queriesDir,\n      query.endsWith('.sql') ? query : `${query}.sql`,\n    )\n\n    if (!filePath.includes(this.queriesDir)) {\n      throw new SourceFileNotFoundError(\n        `Query file is not in the queries directory: ${filePath}`,\n      )\n    }\n\n    if (!fs.existsSync(filePath)) {\n      throw new QueryNotFoundError(`Query file not found at ${filePath}`)\n    }\n\n    const sourceFilePath = findSourceConfigFromQuery({\n      query,\n      queriesDir: this.queriesDir,\n    })\n\n    const sourcePath = path.relative(\n      this.queriesDir,\n      path.dirname(sourceFilePath),\n    )\n\n    if (!this.instances[sourcePath]) {\n      this.buildSource({ sourcePath, sourceFile: sourceFilePath })\n    }\n\n    return this.instances[sourcePath]!\n  }\n\n  /**\n   * Loads a source from a source configuration file\n   * @param sourceFile - The path to the source configuration file\n   */\n  async loadFromConfigFile(sourceFile: string): Promise<Source> {\n    if (!path.isAbsolute(sourceFile)) {\n      sourceFile = path.join(this.queriesDir, sourceFile)\n    }\n\n    if (!fs.existsSync(sourceFile)) {\n      throw new SourceFileNotFoundError(\n        `Source file not found at ${sourceFile}`,\n      )\n    }\n\n    // If the given path is not in queriesDir, throw an error\n    if (!sourceFile.includes(this.queriesDir)) {\n      throw new SourceFileNotFoundError(\n        `Source file is not in the queries directory: ${sourceFile}`,\n      )\n    }\n\n    const sourcePath = path.dirname(sourceFile)\n    if (!this.instances[sourcePath]) {\n      this.buildSource({ sourcePath, sourceFile })\n    }\n\n    return this.instances[sourcePath]!\n  }\n\n  /**\n   * Safely closes the connection to a source and removes the instance from the cache\n   */\n  async clear(source: Source): Promise<void> {\n    await source.endConnection()\n    delete this.instances[source.path]\n  }\n\n  /**\n   * Clears all sources and closes all connections\n   */\n  async clearAll(): Promise<void> {\n    await Promise.all(\n      Object.values(this.instances).map((source) => this.clear(source)),\n    )\n  }\n\n  private buildSource({\n    sourceFile,\n    sourcePath,\n  }: {\n    sourceFile: string\n    sourcePath: string\n  }) {\n    const schema = readSourceConfig(sourceFile)\n    this.instances[sourcePath] = new Source({\n      path: sourcePath,\n      schema,\n      sourceManager: this,\n    })\n  }\n}\n","import fs from 'fs'\nimport path from 'path'\n\nimport {\n  MaterializedFileNotFoundError,\n  ResolveUrlParams,\n  StorageDriver,\n} from '@/materialize/drivers/StorageDriver'\nimport { FullDriverConfig } from '@/materialize'\n\nexport default class DiskDriver extends StorageDriver {\n  private materializeDir: string\n\n  constructor({ path, manager }: FullDriverConfig<'disk'>) {\n    super({ manager })\n\n    this.materializeDir = path\n  }\n\n  get basePath(): string {\n    return this.materializeDir\n  }\n\n  resolveUrl({\n    queryName,\n    filename,\n    ignoreMissingFile = false,\n  }: ResolveUrlParams): Promise<string> {\n    const filepath = path.join(this.materializeDir, filename)\n\n    if (ignoreMissingFile) return Promise.resolve(filepath)\n\n    if (fs.existsSync(filepath)) return Promise.resolve(filepath)\n\n    return Promise.reject(\n      new MaterializedFileNotFoundError(\n        `materialize query not found for: '${queryName}'`,\n      ),\n    )\n  }\n}\n","import fs from 'fs'\nimport path from 'path'\nimport { StorageDriver } from '@/materialize/drivers'\nimport { DiskDriver } from '@/materialize/drivers'\nimport SourceManager from '@/manager'\n\nclass NoDiskDriverError extends Error {\n  constructor() {\n    super('Disk driver is required for materializing queries')\n  }\n}\n\nclass NonMaterializableQueryError extends Error {\n  constructor(query: string) {\n    super(`Query ${query} is not materializable`)\n  }\n}\n\nfunction ensureMaterializeDirExists(storage: StorageDriver) {\n  if (!(storage instanceof DiskDriver)) {\n    throw new NoDiskDriverError()\n  }\n\n  const basePath = storage.basePath\n  if (!fs.existsSync(basePath)) {\n    fs.mkdirSync(basePath, { recursive: true })\n  }\n}\n\nfunction parseTime({ start, end }: { start: number; end: number }) {\n  const minuteTime = Math.floor((end - start) / 60000)\n  const min = minuteTime.toString().padStart(2, '0')\n  const secondsTime = ((end - start) % 60000) / 1000\n  const seconds = minuteTime\n    ? secondsTime.toFixed(0).padStart(2, '0')\n    : secondsTime.toFixed(2).padStart(5, '0')\n  return minuteTime ? `${min}:${seconds} minutes` : `${seconds} seconds`\n}\n\nfunction humanizeFileSize(bytes: number): string {\n  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB']\n  if (bytes === 0) return '0 Byte'\n  const i = Math.floor(Math.log(bytes) / Math.log(1024))\n  return parseFloat((bytes / Math.pow(1024, i)).toFixed(2)) + ' ' + sizes[i]\n}\n\nfunction buildInfo({\n  startTime,\n  endTime,\n  query,\n  filePath,\n  queryRows,\n}: {\n  startTime: number\n  endTime: number\n  query: string\n  filePath: string\n  queryRows: number\n}) {\n  const file = path.basename(filePath)\n  return {\n    query,\n    queryRows: `${queryRows.toLocaleString('de-DE', {\n      style: 'decimal',\n      useGrouping: true,\n    })} rows`,\n    time: parseTime({ start: startTime, end: endTime }),\n    fileSize: humanizeFileSize(fs.statSync(filePath).size),\n    file,\n  }\n}\n\nfunction recursiveFindQueriesInDir(\n  rootDir: string,\n  nextDir?: string,\n): string[] {\n  const dir = nextDir ?? rootDir\n  const files = fs.readdirSync(dir)\n  return files.flatMap((file) => {\n    const fullPath = path.join(dir, file)\n    const isDir = fs.statSync(fullPath).isDirectory()\n\n    if (isDir) return recursiveFindQueriesInDir(rootDir, fullPath)\n\n    const relativePath = fullPath.replace(rootDir, '').replace(/^\\//, '')\n    return fullPath.endsWith('.sql') ? [relativePath] : []\n  })\n}\n\nasync function isMaterializableQuery({\n  sourceManager,\n  query,\n}: {\n  sourceManager: SourceManager\n  query: string\n}) {\n  const source = await sourceManager.loadFromQuery(query)\n  const { config } = await source.getMetadataFromQuery(query)\n  return config.materialize === true\n}\n\nasync function findQueries({\n  sourceManager,\n  selected,\n}: {\n  sourceManager: SourceManager\n  selected: string[]\n}) {\n  const storage = sourceManager.materializeStorage\n  ensureMaterializeDirExists(storage)\n\n  const queriesDir = sourceManager.queriesDir\n  const allQueries = recursiveFindQueriesInDir(queriesDir)\n\n  // We don' filter queries if user pass a specific list\n  // If one of then is not materializable we fail\n  if (selected.length > 0) {\n    return Promise.all(\n      allQueries\n        .filter((query) =>\n          selected.some(\n            (selectedQuery) =>\n              query === selectedQuery || query === `${selectedQuery}.sql`,\n          ),\n        )\n        .map(async (query) => {\n          const canMaterialize = await isMaterializableQuery({\n            sourceManager,\n            query,\n          })\n\n          if (!canMaterialize) {\n            throw new NonMaterializableQueryError(query)\n          }\n\n          return query\n        }),\n    )\n  }\n\n  const queries = await Promise.all(\n    allQueries.map(async (query) => {\n      const canMaterialize = await isMaterializableQuery({\n        sourceManager,\n        query,\n      })\n      return { query, canMaterialize }\n    }),\n  )\n\n  return queries.filter((q) => q.canMaterialize).map((q) => q.query)\n}\n\ntype MaterializeInfo = {\n  query: string\n  file: string\n  fileSize: string\n  time: string\n  queryRows: string\n}\n\nconst BATCH_SIZE = 4096\ntype Result = {\n  successful: boolean\n  totalTime: string\n  batchSize: number\n  queriesInfo: MaterializeInfo[]\n}\nexport default async function findAndMaterializeQueries({\n  sourceManager,\n  onStartQuery,\n  onDebug,\n  selectedQueries = [],\n}: {\n  selectedQueries?: string[]\n  onStartQuery?: (_p: { count: number; index: number; query: string }) => void\n  onDebug?: (_p: { memoryUsageInMb: string }) => void\n  sourceManager: SourceManager\n}): Promise<Result> {\n  const startTotalTime = performance.now()\n  const info: MaterializeInfo[] = []\n  const result: Result = {\n    batchSize: BATCH_SIZE,\n    successful: false,\n    totalTime: '',\n    queriesInfo: [],\n  }\n  const storage = sourceManager.materializeStorage\n\n  try {\n    const queries = await findQueries({\n      sourceManager,\n      selected: selectedQueries,\n    })\n\n    for (const [index, query] of queries.entries()) {\n      const startTime = performance.now()\n      onStartQuery?.({ count: queries.length, index: index + 1, query })\n      const materialize = await storage.writeParquet({\n        onDebug,\n        queryPath: query,\n        params: {},\n        batchSize: BATCH_SIZE,\n      })\n\n      const endTime = performance.now()\n      info.push(\n        buildInfo({\n          startTime,\n          endTime,\n          query,\n          filePath: materialize.filePath,\n          queryRows: materialize.queryRows,\n        }),\n      )\n    }\n    result.successful = true\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'test') {\n      console.error(error)\n    }\n    result.successful = false\n  } finally {\n    const endTotalTime = performance.now()\n    const totalTime = parseTime({ start: startTotalTime, end: endTotalTime })\n    result.totalTime = totalTime\n    result.queriesInfo = info\n  }\n\n  return result\n}\n","import SourceManager from '@/manager'\nimport DiskDriver from '@/materialize/drivers/disk/DiskDriver'\n\nexport { default as findAndMaterializeQueries } from './findAndMaterializeQueries'\nexport const STORAGE_TYPES = { disk: 'disk' }\nexport type StorageType = keyof typeof STORAGE_TYPES\nexport type FullDriverConfig<T extends StorageType> = DriverConfig<T> & {\n  manager: SourceManager\n}\nexport type DriverConfig<T extends StorageType> = T extends 'disk'\n  ? { path: string }\n  : never\nexport type StorageConfig<T extends StorageType> = {\n  type: T\n  config: DriverConfig<T>\n}\nexport type StorageKlass = typeof DiskDriver\n\nexport function getDriverKlass({\n  type,\n}: {\n  type: StorageType\n}): StorageKlass | null {\n  switch (type) {\n    case STORAGE_TYPES.disk:\n      return DiskDriver\n    default: {\n      return null\n    }\n  }\n}\n"],"names":["buildInterpolate","buildParam","buildRef","buildRunQuery","buildCast","fs"],"mappings":"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"}