import { QueryMetadata, SupportedMethod, type CompileError } from '@latitude-data/sql-compiler';
import type QueryResult from '@latitude-data/query_result';
import { Source } from '@/source';
import type { ResolvedParam, CompiledQuery, CompilationContext, BuildSupportedMethodsArgs, CompileQueryRequest, BatchedQueryOptions, QueryConfig } from '@/types';
export type ConnectorAttributes = {
    [key: string]: unknown;
};
export { CompileError };
export type ConnectorOptions<P extends ConnectorAttributes> = {
    source: Source;
    connectionParams: P;
};
export declare abstract class BaseConnector<P extends ConnectorAttributes = {}> {
    protected source: Source;
    constructor({ source }: ConnectorOptions<P>);
    /**
     * While compiling the query, the connector will call this method to resolve the
     * parameterised string for a variable. The index is the position of this variable
     * in the array of ResolvedParams that will be passed to the runQuery method.
     */
    protected abstract resolve(value: unknown, index: number): ResolvedParam;
    /**
     * Perform the actual query execution on the data source.
     */
    protected abstract runQuery(request: CompiledQuery): Promise<QueryResult>;
    /**
     * The connector is able to perform streaming (batching) of the results
     * of a query. If the connector does not define this method it will throw
     */
    batchQuery(_c: CompiledQuery, _o: BatchedQueryOptions): Promise<void>;
    /**
     * Close the connection to the data source.
     * This method must only be called once all queries have been executed and the
     * connector instance is no longer needed.
     */
    end(): Promise<void>;
    /**
     * Compile the given query. This method returns the compiled SQL, resolved parameters,
     * and information about the compilation process.
     */
    compileQuery(context: CompilationContext): Promise<CompiledQuery>;
    /**
     * Parses the query and returns the configuration defined and methods used.
     * This definition is static, and only depends on the contents of the query
     * itself.
     */
    readMetadata(request: CompileQueryRequest): Promise<QueryMetadata<QueryConfig>>;
    runCompiled(request: CompiledQuery): Promise<QueryResult>;
    protected buildSupportedMethods(buildArgs: BuildSupportedMethodsArgs): Record<string, SupportedMethod>;
}
//# sourceMappingURL=index.d.ts.map