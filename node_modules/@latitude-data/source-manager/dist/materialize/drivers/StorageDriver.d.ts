import SourceManager from '@/manager';
import { QueryRequest } from '@/types';
export type GetUrlParams = {
    sqlHash: string;
    queryName: string;
    sourcePath: string;
    ignoreMissingFile?: boolean;
};
export type ResolveUrlParams = GetUrlParams & {
    filename: string;
    ignoreMissingFile?: boolean;
};
export declare class MaterializedFileNotFoundError extends Error {
}
type Result = {
    filePath: string;
    queryRows: number;
};
export type WriteParquetParams = QueryRequest & {
    batchSize?: number;
    onDebug?: (_p: {
        memoryUsageInMb: string;
    }) => void;
};
/**
 * In order to hash a SQL query, we need to know the source path
 * it came from. This way we ensure the path is unique even
 * if two sources share the same query.
 */
export declare abstract class StorageDriver {
    private manager;
    constructor({ manager }: {
        manager: SourceManager;
    });
    abstract get basePath(): string;
    writeParquet({ queryPath, params, batchSize, onDebug, }: WriteParquetParams): Promise<Result>;
    getUrl(args: GetUrlParams): Promise<string>;
    /**
     * It's a Promise because other adapters can be async
     */
    abstract resolveUrl({ filename }: ResolveUrlParams): Promise<string>;
    static hashName({ sqlHash, sourcePath }: GetUrlParams): string;
    private buildParquetSchema;
}
export {};
//# sourceMappingURL=StorageDriver.d.ts.map