import { locate } from 'locate-character';
import { isIdentifierStart, isIdentifierChar } from 'acorn';
import * as code_red from 'code-red';
import { createHash } from 'node:crypto';

class CompileError extends Error {
    code;
    start;
    end;
    pos;
    frame;
    toString() {
        if (!this.start)
            return this.message;
        return `${this.message} (${this.start.line}:${this.start.column})\n${this.frame}`;
    }
}
function tabsToSpaces(str) {
    return str.replace(/^\t+/, (match) => match.split('\t').join('  '));
}
function getCodeFrame(source, line, startColumn, endColumn) {
    const lines = source.split('\n');
    const frameStart = Math.max(0, line - 2);
    const frameEnd = Math.min(line + 3, lines.length);
    const digits = String(frameEnd + 1).length;
    return lines
        .slice(frameStart, frameEnd)
        .map((str, i) => {
        const isErrorLine = frameStart + i === line;
        const lineNum = String(i + frameStart + 1).padStart(digits, ' ');
        if (isErrorLine) {
            const indicator = ' '.repeat(digits + 2 + tabsToSpaces(str.slice(0, startColumn)).length) +
                '^' +
                '~'.repeat(endColumn ? Math.max(0, endColumn - startColumn - 1) : 0);
            return `${lineNum}: ${tabsToSpaces(str)}\n\n${indicator}`;
        }
        return `${lineNum}: ${tabsToSpaces(str)}`;
    })
        .join('\n');
}
function error(message, props) {
    const error = new CompileError(message);
    error.name = props.name;
    const start = locate(props.source, props.start, { offsetLine: 1 });
    const end = locate(props.source, props.end || props.start, { offsetLine: 1 });
    error.code = props.code;
    error.start = start;
    error.end = end;
    error.pos = props.start;
    error.frame = getCodeFrame(props.source, (start?.line ?? 1) - 1, start?.column ?? 0, end?.column);
    throw error;
}

function getKlassName(error) {
    const errorKlass = error;
    return errorKlass.constructor ? errorKlass.constructor.name : 'Error';
}
var errors = {
    unexpectedEof: {
        code: 'unexpected-eof',
        message: 'Unexpected end of input',
    },
    unexpectedEofToken: (token) => ({
        code: 'unexpected-eof',
        message: `Unexpected '${token}'`,
    }),
    unexpectedToken: (token) => ({
        code: 'unexpected-token',
        message: `Expected '${token}'`,
    }),
    unexpectedBlockClose: {
        code: 'unexpected-block-close',
        message: 'Unexpected block closing tag',
    },
    invalidElseif: {
        code: 'invalid-elseif',
        message: "'elseif' should be 'else if'",
    },
    invalidElseifPlacementUnclosedBlock: (block) => ({
        code: 'invalid-elseif-placement',
        message: `Expected to close ${block} before seeing {:else if ...} block`,
    }),
    invalidElseifPlacementOutsideIf: {
        code: 'invalid-elseif-placement',
        message: 'Cannot have an {:else if ...} block outside an {#if ...} block',
    },
    invalidElsePlacementUnclosedBlock: (block) => ({
        code: 'invalid-else-placement',
        message: `Expected to close ${block} before seeing {:else} block`,
    }),
    invalidElsePlacementOutsideIf: {
        code: 'invalid-else-placement',
        message: 'Cannot have an {:else} block outside an {#if ...} or {#each ...} block',
    },
    expectedBlockType: {
        code: 'expected-block-type',
        message: 'Expected if or each',
    },
    unexpectedTokenDestructure: {
        code: 'unexpected-token',
        message: 'Expected identifier or destructure pattern',
    },
    expectedName: {
        code: 'expected-name',
        message: 'Expected name',
    },
    unexpectedMustacheCloseTag: {
        code: 'unexpected-mustache-close-tag',
        message: 'Unexpected closing tag without matching opening tag',
    },
    unexpectedEndOfComment: {
        code: 'unexpected-end-of-comment',
        message: 'Unexpected end of comment',
    },
    // Compiler errors:
    queryNotFound: (name) => ({
        code: 'query-not-found',
        message: `Query '${name}' not found`,
    }),
    unsupportedBaseNodeType: (type) => ({
        code: 'unsupported-base-node-type',
        message: `Unsupported base node type: ${type}`,
    }),
    unsupportedExpressionType: (type) => ({
        code: 'unsupported-expression-type',
        message: `Unsupported expression type: ${type}`,
    }),
    invalidConstantDefinition: {
        code: 'invalid-constant-definition',
        message: 'Constant definitions must assign a value to a variable',
    },
    invalidConfigDefinition: {
        code: 'invalid-config-definition',
        message: 'Config definitions must assign a value to an option',
    },
    invalidConfigValue: {
        code: 'invalid-config-value',
        message: 'Config values must be literals. Cannot use variables or expressions',
    },
    configInsideBlock: {
        code: 'config-inside-block',
        message: 'Cannot must be defined at root level. Cannot be inside a block',
    },
    configDefinitionFailed: (name, message) => ({
        code: 'config-definition-failed',
        message: `Config definition for '${name}' failed: ${message}`,
    }),
    configAlreadyDefined: (name) => ({
        code: 'config-already-defined',
        message: `Config definition for '${name}' failed: Option already configured`,
    }),
    variableAlreadyDeclared: (name) => ({
        code: 'variable-already-declared',
        message: `Variable '${name}' is already declared`,
    }),
    variableNotDeclared: (name) => ({
        code: 'variable-not-declared',
        message: `Variable '${name}' is not declared`,
    }),
    invalidObjectKey: {
        code: 'invalid-object-key',
        message: 'Invalid object key',
    },
    unsupportedOperator: (operator) => ({
        code: 'unsupported-operator',
        message: `Unsupported operator: ${operator}`,
    }),
    constantReassignment: {
        code: 'constant-reassignment',
        message: 'Cannot reassign a constant',
    },
    invalidAssignment: {
        code: 'invalid-assignment',
        message: 'Invalid assignment',
    },
    invalidUpdate: (operation, type) => ({
        code: 'invalid-update',
        message: `Cannot use ${operation} operation on ${type}`,
    }),
    propertyNotExists: (property) => ({
        code: 'property-not-exists',
        message: `Property '${property}' does not exist on object`,
    }),
    unknownFunction: (name) => ({
        code: 'unknown-function',
        message: `Unknown function: ${name}`,
    }),
    notAFunction: (objectType) => ({
        code: 'not-a-function',
        message: `Object '${objectType}' is callable`,
    }),
    functionCallError: (err) => {
        const error = err;
        const errorKlassName = getKlassName(error);
        return {
            code: 'function-call-error',
            message: `Error calling function: \n${errorKlassName} ${error.message}`,
        };
    },
    functionRequiresStaticArguments: (name) => ({
        code: 'function-requires-static-arguments',
        message: `Function '${name}' can only receive literal values as arguments`,
    }),
    functionRequiresInterpolation: (name) => ({
        code: 'function-requires-interpolation',
        message: `Function '${name}' cannot be used inside a logic block. It must be directly interpolated into the query`,
    }),
    functionDisallowsInterpolation: (name) => ({
        code: 'function-disallows-interpolation',
        message: `Function '${name}' cannot be directly interpolated into the query`,
    }),
    invalidFunctionResultInterpolation: {
        code: 'invalid-function-result-interpolation',
        message: 'Functions called for interpolation must return a string',
    },
};

// Adapted from https://github.com/acornjs/acorn/blob/6584815dca7440e00de841d1dad152302fdd7ca5/src/tokenize.js
function fullCharCodeAt(str, i) {
    const code = str.charCodeAt(i);
    if (code <= 0xd7ff || code >= 0xe000)
        return code;
    const next = str.charCodeAt(i + 1);
    return (code << 10) + next - 0x35fdc00;
}

const reserved = new Set([
    'arguments',
    'await',
    'break',
    'case',
    'catch',
    'class',
    'const',
    'continue',
    'debugger',
    'default',
    'delete',
    'do',
    'else',
    'enum',
    'eval',
    'export',
    'extends',
    'false',
    'finally',
    'for',
    'function',
    'if',
    'implements',
    'import',
    'in',
    'instanceof',
    'interface',
    'let',
    'new',
    'null',
    'package',
    'private',
    'protected',
    'public',
    'return',
    'static',
    'super',
    'switch',
    'this',
    'throw',
    'true',
    'try',
    'typeof',
    'var',
    'void',
    'while',
    'with',
    'yield',
]);

function dashComment(parser) {
    const start = parser.index;
    let data = '';
    while (parser.index < parser.template.length) {
        if (parser.matchRegex(/\n/)) {
            break;
        }
        data += parser.template[parser.index++];
    }
    const node = {
        start,
        end: parser.index,
        type: 'Comment',
        raw: data,
        data: data.substring(2),
    };
    parser.current().children.push(node);
}

function multiLineComment(parser) {
    if (parser.match('*/')) {
        parser.error(errors.unexpectedEndOfComment);
    }
    const start = parser.index;
    while (parser.index < parser.template.length) {
        if (parser.matchRegex(/\*\//)) {
            parser.index += 2;
            break;
        }
        parser.index++;
    }
    const data = parser.template.substring(start, parser.index);
    const node = {
        start,
        end: parser.index + 1,
        type: 'Comment',
        raw: data,
        data: data.substring(2, data.length - 2),
    };
    parser.current().children.push(node);
}

const parseExpressionAt = (source, index) => code_red.parseExpressionAt(source, index, {
    sourceType: 'module',
    ecmaVersion: 13,
    locations: true,
});

function readExpression(parser) {
    try {
        const node = parseExpressionAt(parser.template, parser.index);
        let numParenthesis = 0;
        for (let i = parser.index; i < node.start; i += 1) {
            if (parser.template[i] === '(')
                numParenthesis += 1;
        }
        let index = node.end;
        while (numParenthesis > 0) {
            const char = parser.template[index];
            if (char === ')') {
                numParenthesis -= 1;
            }
            else if (!/\s/.test(char)) {
                parser.error(errors.unexpectedToken(')'), index);
            }
            index += 1;
        }
        parser.index = index;
        return node;
    }
    catch (err) {
        parser.acornError(err);
    }
}

const SQUARE_BRACKET_OPEN = '['.charCodeAt(0);
const SQUARE_BRACKET_CLOSE = ']'.charCodeAt(0);
const CURLY_BRACKET_OPEN = '{'.charCodeAt(0);
const CURLY_BRACKET_CLOSE = '}'.charCodeAt(0);
function isBracketOpen(code) {
    return code === SQUARE_BRACKET_OPEN || code === CURLY_BRACKET_OPEN;
}
function isBracketClose(code) {
    return code === SQUARE_BRACKET_CLOSE || code === CURLY_BRACKET_CLOSE;
}
function isBracketPair(open, close) {
    return ((open === SQUARE_BRACKET_OPEN && close === SQUARE_BRACKET_CLOSE) ||
        (open === CURLY_BRACKET_OPEN && close === CURLY_BRACKET_CLOSE));
}
function getBracketClose(open) {
    if (open === SQUARE_BRACKET_OPEN) {
        return SQUARE_BRACKET_CLOSE;
    }
    if (open === CURLY_BRACKET_OPEN) {
        return CURLY_BRACKET_CLOSE;
    }
}

// @ts-expect-error - no types for this package
function readContext(parser) {
    const start = parser.index;
    let i = parser.index;
    const code = fullCharCodeAt(parser.template, i);
    if (isIdentifierStart(code, true)) {
        return {
            type: 'Identifier',
            name: parser.readIdentifier(),
            start,
            end: parser.index,
        };
    }
    if (!isBracketOpen(code)) {
        parser.error(errors.unexpectedTokenDestructure);
    }
    const bracketStack = [code];
    i += code <= 0xffff ? 1 : 2;
    while (i < parser.template.length) {
        const code = fullCharCodeAt(parser.template, i);
        if (isBracketOpen(code)) {
            bracketStack.push(code);
        }
        else if (isBracketClose(code)) {
            if (!isBracketPair(bracketStack[bracketStack.length - 1], code)) {
                parser.error(errors.unexpectedToken(String.fromCharCode(getBracketClose(bracketStack[bracketStack.length - 1]) ?? 0)));
            }
            bracketStack.pop();
            if (bracketStack.length === 0) {
                i += code <= 0xffff ? 1 : 2;
                break;
            }
        }
        i += code <= 0xffff ? 1 : 2;
    }
    parser.index = i;
    const patternString = parser.template.slice(start, i);
    try {
        // the length of the `space_with_newline` has to be start - 1
        // because we added a `(` in front of the pattern_string,
        // which shifted the entire string to right by 1
        // so we offset it by removing 1 character in the `space_with_newline`
        // to achieve that, we remove the 1st space encountered,
        // so it will not affect the `column` of the node
        let spaceWithNewLine = parser.template
            .slice(0, start)
            .replace(/[^\n]/g, ' ');
        const firstSpace = spaceWithNewLine.indexOf(' ');
        spaceWithNewLine =
            spaceWithNewLine.slice(0, firstSpace) +
                spaceWithNewLine.slice(firstSpace + 1);
        return parseExpressionAt(`${spaceWithNewLine}(${patternString} = 1)`, start - 1).left;
    }
    catch (error) {
        parser.acornError(error);
    }
    return {
        type: 'Identifier',
        name: '',
        start: parser.index,
        end: parser.index,
    };
}

function mustache(parser) {
    if (parser.match('}')) {
        parser.error(errors.unexpectedMustacheCloseTag);
    }
    const start = parser.index;
    parser.index += 1;
    parser.allowWhitespace();
    // {/if}, {/each}, {/await} or {/key}
    if (parser.eat('/')) {
        let block = parser.current();
        let expected;
        if (block.type === 'ElseBlock') {
            block.end = start;
            parser.stack.pop();
            block = parser.current();
            expected = 'else';
        }
        if (block.type === 'IfBlock') {
            expected = 'if';
        }
        else if (block.type === 'EachBlock') {
            expected = 'each';
        }
        else {
            parser.error(errors.unexpectedBlockClose);
        }
        parser.eat(expected, true);
        parser.allowWhitespace();
        parser.eat('}', true);
        while (block.elseif) {
            block.end = parser.index;
            parser.stack.pop();
            block = parser.current();
            if (block.else) {
                block.else.end = start;
            }
        }
        // strip leading/trailing whitespace as necessary
        const charBefore = parser.template[block.start - 1];
        const charAfter = parser.template[parser.index];
        const trimBefore = !charBefore || /\s/.test(charBefore);
        const trimAfter = !charAfter || /\s/.test(charAfter);
        trimWhitespace(block, trimBefore, trimAfter);
        block.end = parser.index;
        parser.stack.pop();
    }
    else if (parser.eat(':else')) {
        if (parser.eat('if')) {
            parser.error(errors.invalidElseif);
        }
        parser.allowWhitespace();
        // :else if
        if (parser.eat('if')) {
            const block = parser.current();
            if (block.type !== 'IfBlock') {
                parser.error(parser.stack.some((block) => block.type === 'IfBlock')
                    ? errors.invalidElseifPlacementUnclosedBlock(toString(block))
                    : errors.invalidElseifPlacementOutsideIf);
            }
            parser.requireWhitespace();
            const expression = readExpression(parser);
            parser.allowWhitespace();
            parser.eat('}', true);
            block.else = {
                start: parser.index,
                end: null,
                type: 'ElseBlock',
                children: [
                    {
                        start: parser.index,
                        end: null,
                        type: 'IfBlock',
                        elseif: true,
                        expression,
                        children: [],
                    },
                ],
            };
            parser.stack.push(block.else.children[0]);
        }
        else {
            // :else
            const block = parser.current();
            if (block.type !== 'IfBlock' && block.type !== 'EachBlock') {
                parser.error(parser.stack.some((block) => block.type === 'IfBlock' || block.type === 'EachBlock')
                    ? errors.invalidElsePlacementUnclosedBlock(toString(block))
                    : errors.invalidElsePlacementOutsideIf);
            }
            parser.allowWhitespace();
            parser.eat('}', true);
            block.else = {
                start: parser.index,
                end: null,
                type: 'ElseBlock',
                children: [],
            };
            parser.stack.push(block.else);
        }
    }
    else if (parser.eat('#')) {
        // {#if foo}, {#each foo} or {#await foo}
        const isIf = parser.eat('if');
        const isEach = parser.eat('each');
        if (!isIf && !isEach) {
            parser.error(errors.expectedBlockType);
        }
        const type = isIf ? 'IfBlock' : 'EachBlock';
        parser.requireWhitespace();
        const expression = readExpression(parser);
        const block = {
            start,
            end: start,
            type,
            expression,
            children: [],
        };
        parser.allowWhitespace();
        // {#each} blocks must declare a context â€“ {#each list as item}
        if (type === 'EachBlock') {
            parser.eat('as', true);
            parser.requireWhitespace();
            block['context'] = readContext(parser);
            parser.allowWhitespace();
            if (parser.eat(',')) {
                parser.allowWhitespace();
                block.index = parser.readIdentifier();
                if (!block.index)
                    parser.error(errors.expectedName);
                parser.allowWhitespace();
            }
            if (parser.eat('(')) {
                parser.allowWhitespace();
                block.key = readExpression(parser);
                parser.allowWhitespace();
                parser.eat(')', true);
                parser.allowWhitespace();
            }
        }
        parser.eat('}', true);
        parser.current().children.push(block);
        parser.stack.push(block);
    }
    else if (parser.eat('@const')) {
        // {@const a = b}
        parser.requireWhitespace();
        const expression = readExpression(parser);
        if (!(expression.type === 'AssignmentExpression' &&
            expression.operator === '=')) {
            parser.error({
                code: 'invalid-const-args',
                message: '{@const ...} must be an assignment.',
            }, start);
        }
        parser.allowWhitespace();
        parser.eat('}', true);
        parser.current().children.push({
            start,
            end: parser.index,
            type: 'ConstTag',
            expression,
        });
    }
    else if (parser.eat('@config')) {
        // {@config a = b}
        parser.requireWhitespace();
        const expression = readExpression(parser);
        if (!(expression.type === 'AssignmentExpression' &&
            expression.operator === '=')) {
            parser.error({
                code: 'invalid-config-args',
                message: '{@config ...} must be an assignment.',
            }, start);
        }
        parser.allowWhitespace();
        parser.eat('}', true);
        parser.current().children.push({
            start,
            end: parser.index,
            type: 'ConfigTag',
            expression,
        });
    }
    else {
        const expression = readExpression(parser);
        parser.allowWhitespace();
        parser.eat('}', true);
        parser.current().children.push({
            start,
            end: parser.index,
            type: 'MustacheTag',
            expression,
        });
    }
}
function trimWhitespace(block, trimBefore = false, trimAfter = false) {
    if (!block.children || block.children.length === 0)
        return; // AwaitBlock
    const firstChild = block.children[0];
    const lastChild = block.children[block.children.length - 1];
    if (firstChild.type === 'Text' && trimBefore) {
        firstChild.data = firstChild.data.replace(/^[ \t\r\n]*/, '');
        if (!firstChild.data)
            block.children.shift();
    }
    if (lastChild.type === 'Text' && trimAfter) {
        lastChild.data = lastChild.data.replace(/[ \t\r\n]*$/, '');
        if (!lastChild.data)
            block.children.pop();
    }
    if (block.else) {
        trimWhitespace(block.else, trimBefore, trimAfter);
    }
    if (firstChild.elseif) {
        trimWhitespace(firstChild, trimBefore, trimAfter);
    }
}
function toString(node) {
    switch (node.type) {
        case 'IfBlock':
            return '{#if} block';
        case 'ElseBlock':
            return '{:else} block';
        case 'EachBlock':
            return '{#each} block';
        case 'ConstTag':
            return '{@const} tag';
        case 'ConfigTag':
            return '{@config} tag';
        default:
            return node.type;
    }
}

const STRING_DELIMITERS_REGEX = /['"`]/;
function textInString(parser, char) {
    let data = '';
    while (parser.index < parser.template.length) {
        if (parser.match(char) &&
            !parser.match(char.repeat(2)) &&
            !data.match(/(?<!\\)(\\\\)*\\/)) {
            break;
        }
        data += parser.template[parser.index++];
    }
    parser.index++;
    return char + data + char;
}
const ENDS_WITH_ESCAPE_REGEX = /(?<!\\)(\\\\)*\\$/;
const RESERVED_DELIMITERS = ['{', '}', '--', '/*', '*/'];
function text(parser) {
    const start = parser.index;
    let data = '';
    while (parser.index < parser.template.length) {
        const isEscaping = ENDS_WITH_ESCAPE_REGEX.test(data);
        if (isEscaping)
            data = data.slice(0, -1); // Remove the escape character
        if (!isEscaping &&
            RESERVED_DELIMITERS.some((sample) => parser.match(sample))) {
            break;
        }
        if (!isEscaping && parser.matchRegex(STRING_DELIMITERS_REGEX)) {
            data += textInString(parser, parser.template[parser.index++]);
            continue;
        }
        data += parser.template[parser.index++];
    }
    const node = {
        start,
        end: parser.index,
        type: 'Text',
        raw: data,
        data: data.replace(/(?<!\\)\\{/g, '{').replace(/(?<!\\)\\}/g, '}'),
    };
    parser.current().children.push(node);
}

function fragment(parser) {
    if (parser.match('{') || parser.match('}')) {
        return mustache;
    }
    if (parser.match('/*') || parser.match('*/')) {
        return multiLineComment;
    }
    if (parser.match('--')) {
        return dashComment;
    }
    return text;
}

function parse(template) {
    return new Parser(template).parse();
}
class Parser {
    template;
    index = 0;
    stack = [];
    constructor(template) {
        this.template = template;
    }
    parse() {
        const template = {
            start: 0,
            end: this.template.length,
            type: 'Fragment',
            children: [],
        };
        this.stack.push(template);
        let state = fragment;
        while (this.index < this.template.length) {
            state = state(this) || fragment;
        }
        if (this.stack.length > 1) {
            const current = this.current();
            this.error({
                code: `unclosed-block`,
                message: `Block was left open`,
            }, current.start);
        }
        if (state !== fragment) {
            this.error({
                code: `unexpected-eof`,
                message: `Unexpected end of input`,
            });
        }
        if (template.children.length) {
            let start = template.children[0].start;
            while (/\s/.test(template[start]))
                start += 1;
            let end = template.children[template.children.length - 1].end;
            while (/\s/.test(template[end - 1]))
                end -= 1;
            template.start = start;
            template.end = end;
        }
        else {
            template.start = template.end = null;
        }
        return template;
    }
    current() {
        return this.stack[this.stack.length - 1];
    }
    match(str) {
        return this.template.slice(this.index, this.index + str.length) === str;
    }
    allowWhitespace() {
        while (this.index < this.template.length &&
            /\s/.test(this.template[this.index] || '')) {
            this.index++;
        }
    }
    requireWhitespace() {
        if (!/\s/.test(this.template[this.index])) {
            this.error({
                code: 'missing-whitespace',
                message: 'Expected whitespace',
            });
        }
        this.allowWhitespace();
    }
    eat(str, required = false, error) {
        if (this.match(str)) {
            this.index += str.length;
            return true;
        }
        if (required) {
            this.error(error ||
                (this.index === this.template.length
                    ? errors.unexpectedEofToken(str)
                    : errors.unexpectedToken(str)));
        }
        return false;
    }
    error({ code, message }, index = this.index) {
        error(message, {
            name: 'ParseError',
            code,
            source: this.template,
            start: index - 1,
        });
    }
    acornError(err) {
        this.error({
            code: 'parse-error',
            message: err.message.replace(/ \(\d+:\d+\)$/, ''),
        }, err.pos);
    }
    matchRegex(pattern) {
        const match = pattern.exec(this.template.slice(this.index));
        if (!match || match.index !== 0)
            return null;
        return match[0];
    }
    read(pattern) {
        const result = this.matchRegex(pattern);
        if (result)
            this.index += result.length;
        return result;
    }
    readIdentifier(allowReserved = false) {
        const start = this.index;
        let i = this.index;
        const code = fullCharCodeAt(this.template, i);
        if (!isIdentifierStart(code, true))
            return null;
        i += code <= 0xffff ? 1 : 2;
        while (i < this.template.length) {
            const code = fullCharCodeAt(this.template, i);
            if (!isIdentifierChar(code, true))
                break;
            i += code <= 0xffff ? 1 : 2;
        }
        const identifier = this.template.slice(this.index, (this.index = i));
        if (!allowReserved && reserved.has(identifier)) {
            this.error({
                code: 'unexpected-reserved-word',
                message: `'${identifier}' is a reserved word in JavaScript and cannot be used here`,
            }, start);
        }
        return identifier;
    }
}

class Scope {
    /**
     * Global stash
     * All variable values are stored in a single global array. This is done to allow multiple
     * scopes to share the same variable values and be able to modify them.
     *
     * For example:
     * ```sql
     * {var1 = 1}
     * {#if <condition>}
     *  {var1 = 2}
     *  {var2 = 3}
     * {/if}
     * ```
     * In this case, there are two scopes: root and if. Both scopes share the same variable `var1`,
     * and modifying it in the if scope should also modify it in the root scope. But `var2` is only
     * defined in the if scope and should not be accessible in the root scope.
     */
    static stash = []; // Stash of every variable value in every scope
    static readFromStash(index) {
        return Scope.stash[index];
    }
    static addToStash(value) {
        Scope.stash.push(value);
        return Scope.stash.length - 1;
    }
    static modifyStash(index, value) {
        Scope.stash[index] = value;
    }
    /**
     * Local scope
     * Every scope has its own local stash that contains the indexes of the variables and constants
     * in the global stash.
     */
    consts = {}; // Index of every constant in the stash in the current scope
    vars = {}; // Index of every variable in the stash in the current scope
    constructor() { }
    exists(name) {
        return name in this.consts || name in this.vars;
    }
    isConst(name) {
        return name in this.consts;
    }
    get(name) {
        const index = this.consts[name] ?? this.vars[name] ?? undefined;
        if (index === undefined)
            throw new Error(`Variable '${name}' does not exist`);
        return Scope.readFromStash(index);
    }
    defineConst(name, value) {
        if (this.exists(name))
            throw new Error(`Variable '${name}' already exists`);
        this.consts[name] = Scope.addToStash(value);
    }
    set(name, value) {
        if (this.isConst(name))
            throw new Error(`Constant '${name}' cannot be modified`);
        if (!this.exists(name)) {
            this.vars[name] = Scope.addToStash(value);
            return;
        }
        const index = this.vars[name];
        Scope.modifyStash(index, value);
    }
    copy() {
        const scope = new Scope();
        scope.consts = { ...this.consts };
        scope.vars = { ...this.vars };
        return scope;
    }
}

var NodeType;
(function (NodeType) {
    NodeType["Literal"] = "Literal";
    NodeType["Identifier"] = "Identifier";
    NodeType["ObjectExpression"] = "ObjectExpression";
    NodeType["ArrayExpression"] = "ArrayExpression";
    NodeType["SequenceExpression"] = "SequenceExpression";
    NodeType["LogicalExpression"] = "LogicalExpression";
    NodeType["BinaryExpression"] = "BinaryExpression";
    NodeType["UnaryExpression"] = "UnaryExpression";
    NodeType["AssignmentExpression"] = "AssignmentExpression";
    NodeType["UpdateExpression"] = "UpdateExpression";
    NodeType["MemberExpression"] = "MemberExpression";
    NodeType["ConditionalExpression"] = "ConditionalExpression";
    NodeType["CallExpression"] = "CallExpression";
    NodeType["ChainExpression"] = "ChainExpression";
})(NodeType || (NodeType = {}));

function mergeMetadata(...metadata) {
    const config = metadata.reduce((acc, m) => ({ ...acc, ...m.config }), {});
    const methods = metadata.reduce((acc, m) => new Set([...acc, ...m.methods]), new Set());
    const hashes = metadata.map((m) => m.sqlHash).filter(Boolean);
    let sqlHash = undefined;
    if (hashes.length === 1) {
        sqlHash = hashes[0];
    }
    else if (hashes.length > 1) {
        const hash = createHash('sha256');
        for (const h of hashes)
            hash.update(h);
        sqlHash = hash.digest('hex');
    }
    const rawSqls = metadata.map((m) => m.rawSql).filter(Boolean);
    if (rawSqls.length > 1) {
        throw new Error('Cannot merge metadata with multiple rawSqls');
    }
    const rawSql = rawSqls[0];
    return {
        config,
        methods,
        rawSql,
        sqlHash,
    };
}
function emptyMetadata() {
    return {
        config: {},
        methods: new Set(),
        rawSql: undefined,
        sqlHash: undefined,
    };
}

/**
 * ### ArrayExpression
 * Returns an array of values
 */
async function resolve$c({ node, ...props }) {
    return await Promise.all(node.elements.map((element) => element
        ? resolveLogicNode({
            node: element,
            ...props,
        })
        : null));
}
async function readMetadata$b({ node, ...props }) {
    const childrenMetadata = await Promise.all(node.elements.map(async (element) => {
        if (element)
            return await getLogicNodeMetadata({ node: element, ...props });
        return emptyMetadata();
    }));
    return mergeMetadata(...childrenMetadata);
}

// https://github.com/estree/estree/blob/master/es5.md#binary-operations
const BINARY_OPERATOR_METHODS = {
    // BinaryExpression
    '==': (left, right) => left == right,
    '!=': (left, right) => left != right,
    '===': (left, right) => left === right,
    '!==': (left, right) => left !== right,
    '<': (left, right) => left < right,
    '<=': (left, right) => left <= right,
    '>': (left, right) => left > right,
    '>=': (left, right) => left >= right,
    '<<': (left, right) => left << right,
    '>>': (left, right) => left >> right,
    '>>>': (left, right) => left >>> right,
    '+': (left, right) => left + right,
    '-': (left, right) => left - right,
    '*': (left, right) => left * right,
    '/': (left, right) => left / right,
    '%': (left, right) => left % right,
    '|': (left, right) => left | right,
    '^': (left, right) => left ^ right,
    '&': (left, right) => left & right,
    in: (left, right) => left in right,
    instanceof: (left, right) => left instanceof right,
    // LogicalExpression
    '||': (left, right) => left || right,
    '&&': (left, right) => left && right,
    '??': (left, right) => left ?? right,
};
// https://github.com/estree/estree/blob/master/es5.md#unary-operations
const UNARY_OPERATOR_METHODS = {
    // UnaryExpression
    '-': (value, prefix) => (prefix ? -value : value),
    '+': (value, prefix) => (prefix ? +value : value),
    '!': (value, _) => !value,
    '~': (value, _) => ~value,
    typeof: (value, _) => typeof value,
    void: (value, _) => void value,
};
// https://github.com/estree/estree/blob/master/es5.md#memberexpression
const MEMBER_EXPRESSION_METHOD = (object, property) => {
    const value = object[property];
    return typeof value === 'function' ? value.bind(object) : value;
};
// https://github.com/estree/estree/blob/master/es5.md#assignmentexpression
const ASSIGNMENT_OPERATOR_METHODS = {
    '=': (_, right) => right,
    '+=': (left, right) => left + right,
    '-=': (left, right) => left - right,
    '*=': (left, right) => left * right,
    '/=': (left, right) => left / right,
    '%=': (left, right) => left % right,
    '<<=': (left, right) => left << right,
    '>>=': (left, right) => left >> right,
    '>>>=': (left, right) => left >>> right,
    '|=': (left, right) => left | right,
    '^=': (left, right) => left ^ right,
    '&=': (left, right) => left & right,
};

/**
 * ### AssignmentExpression
 * Represents an assignment or update to a variable or property. Returns the newly assigned value.
 * The assignment can be made to an existing variable or property, or to a new one. Assignments to constants are not allowed.
 *
 * Examples: `foo = 1` `obj.foo = 'bar'` `foo += 1`
 */
async function resolve$b({ node, scope, raiseError, ...props }) {
    const assignmentOperator = node.operator;
    if (!(assignmentOperator in ASSIGNMENT_OPERATOR_METHODS)) {
        raiseError(errors.unsupportedOperator(assignmentOperator), node);
    }
    const assignmentMethod = ASSIGNMENT_OPERATOR_METHODS[assignmentOperator];
    const assignmentValue = await resolveLogicNode({
        node: node.right,
        scope,
        raiseError,
        ...props,
    });
    if (node.left.type === 'Identifier') {
        return await assignToVariable({
            assignmentOperator,
            assignmentMethod,
            assignmentValue,
            node: node.left,
            scope,
            raiseError,
            ...props,
        });
    }
    if (node.left.type === 'MemberExpression') {
        return await assignToProperty({
            assignmentOperator,
            assignmentMethod,
            assignmentValue,
            node: node.left,
            scope,
            raiseError,
            ...props,
        });
    }
    raiseError(errors.invalidAssignment, node);
}
async function assignToVariable({ assignmentOperator, assignmentMethod, assignmentValue, node, scope, raiseError, }) {
    const assignedVariableName = node.name;
    if (scope.isConst(assignedVariableName)) {
        raiseError(errors.constantReassignment, node);
    }
    if (assignmentOperator != '=' && !scope.exists(assignedVariableName)) {
        raiseError(errors.variableNotDeclared(assignedVariableName), node);
    }
    const updatedValue = assignmentMethod(scope.exists(assignedVariableName)
        ? scope.get(assignedVariableName)
        : undefined, assignmentValue);
    scope.set(assignedVariableName, updatedValue);
    return updatedValue;
}
async function assignToProperty({ assignmentOperator, assignmentMethod, assignmentValue, node, ...props }) {
    const { raiseError } = props;
    const object = (await resolveLogicNode({
        node: node.object,
        ...props,
    }));
    const property = (node.computed
        ? await resolveLogicNode({
            node: node.property,
            ...props,
        })
        : node.property.name);
    if (assignmentOperator != '=' && !(property in object)) {
        raiseError(errors.propertyNotExists(property), node);
    }
    const originalValue = object[property];
    const updatedValue = assignmentMethod(originalValue, assignmentValue);
    object[property] = updatedValue;
    return updatedValue;
}
async function readMetadata$a({ node, ...props }) {
    return mergeMetadata(await getLogicNodeMetadata({ node: node.right, ...props }), await getLogicNodeMetadata({ node: node.left, ...props }));
}

/**
 * ### Chain Expression
 * Represents a chain of operations. This is only being used for optional member expressions '?.'
 */
async function resolve$a({ node, ...props }) {
    return resolveLogicNode({
        node: node.expression,
        ...props,
    });
}
async function readMetadata$9({ node, ...props }) {
    return await getLogicNodeMetadata({
        node: node.expression,
        ...props,
    });
}

/**
 * ### CallExpression
 * Represents a method call.
 *
 * Examples: `foo()` `foo.bar()`
 */
async function resolve$9(props) {
    const { node, supportedMethods, raiseError } = props;
    if (node.callee.type === NodeType.Identifier &&
        node.callee.name in supportedMethods) {
        return resolveSupportedMethod(props);
    }
    const method = (await resolveLogicNode({
        ...props,
        node: node.callee,
    }));
    if (typeof method !== 'function') {
        raiseError(errors.notAFunction(typeof method), node);
    }
    const args = await resolveArgs(props);
    return await runMethod({ ...props, method, args });
}
async function resolveSupportedMethod(props) {
    const { node, supportedMethods, raiseError, willInterpolate, resolveFn } = props;
    const methodName = node.callee.name;
    const { requirements: reqs, resolve: method } = supportedMethods[methodName];
    const requirements = {
        interpolationPolicy: 'allow',
        interpolationMethod: 'parameterize',
        requireStaticArguments: false,
        ...(reqs ?? {}),
    };
    if (requirements.requireStaticArguments && !onlyContainsStaticArgs(node)) {
        raiseError(errors.functionRequiresStaticArguments(methodName), node);
    }
    if (requirements.interpolationPolicy === 'require' && !willInterpolate) {
        raiseError(errors.functionRequiresInterpolation(methodName), node);
    }
    if (requirements.interpolationPolicy === 'disallow' && willInterpolate) {
        raiseError(errors.functionDisallowsInterpolation(methodName), node);
    }
    const args = await resolveArgs(props);
    const result = await runMethod({ ...props, method, args });
    if (!willInterpolate)
        return result;
    if (requirements?.interpolationMethod === 'raw') {
        return String(result);
    }
    return resolveFn(result);
}
function resolveArgs(props) {
    const { node } = props;
    return Promise.all(node.arguments.map((arg) => resolveLogicNode({
        ...props,
        node: arg,
        willInterpolate: false,
    })));
}
function onlyContainsStaticArgs(node) {
    return node.arguments.every((arg) => arg.type === NodeType.Literal);
}
async function runMethod({ method, args, node, willInterpolate, raiseError, }) {
    try {
        const result = await method(...args);
        if (willInterpolate) {
            return String(result);
        }
        return result;
    }
    catch (error) {
        if (error instanceof CompileError)
            throw error;
        raiseError(errors.functionCallError(error), node);
    }
}
async function readMetadata$8(props) {
    const { node, supportedMethods } = props;
    const argumentsMetadata = await Promise.all(node.arguments.map((arg) => getLogicNodeMetadata({
        ...props,
        node: arg,
    })));
    const calleeMetadata = await getLogicNodeMetadata({
        ...props,
        node: node.callee,
    });
    let resultsMetadata = emptyMetadata();
    if (node.callee.type === NodeType.Identifier) {
        const methodName = node.callee.name;
        if (methodName in supportedMethods) {
            calleeMetadata.methods.add(methodName);
            const args = onlyContainsStaticArgs(node)
                ? node.arguments.map((arg) => arg.value)
                : [];
            resultsMetadata = await supportedMethods[methodName].readMetadata(args);
        }
    }
    return mergeMetadata(calleeMetadata, resultsMetadata, ...argumentsMetadata);
}

/**
 * ### BinaryExpression
 * Represents a simple operation between two operands.
 *
 * Example: `{a > b}`
 */
async function resolve$8({ node, raiseError, ...props }) {
    const binaryOperator = node.operator;
    if (!(binaryOperator in BINARY_OPERATOR_METHODS)) {
        raiseError(errors.unsupportedOperator(binaryOperator), node);
    }
    const leftOperand = await resolveLogicNode({
        node: node.left,
        raiseError,
        ...props,
    });
    const rightOperand = await resolveLogicNode({
        node: node.right,
        raiseError,
        ...props,
    });
    return BINARY_OPERATOR_METHODS[binaryOperator]?.(leftOperand, rightOperand);
}
async function readMetadata$7({ node, ...props }) {
    return mergeMetadata(await getLogicNodeMetadata({
        node: node.left,
        ...props,
    }), await getLogicNodeMetadata({
        node: node.right,
        ...props,
    }));
}

/**
 * ### ConditionalExpression
 * Represents a ternary operation.
 *
 * Example: `a ? b : c`
 */
async function resolve$7({ node, ...props }) {
    const condition = await resolveLogicNode({ node: node.test, ...props });
    return await resolveLogicNode({
        node: condition ? node.consequent : node.alternate,
        ...props,
    });
}
async function readMetadata$6({ node, ...props }) {
    return mergeMetadata(await getLogicNodeMetadata({
        node: node.test,
        ...props,
    }), await getLogicNodeMetadata({
        node: node.consequent,
        ...props,
    }), await getLogicNodeMetadata({
        node: node.alternate,
        ...props,
    }));
}

/**
 * ### Identifier
 * Represents a variable from the scope.
 */
async function resolve$6({ node, scope, raiseError, }) {
    if (!scope.exists(node.name)) {
        raiseError(errors.variableNotDeclared(node.name), node);
    }
    return scope.get(node.name);
}

/**
 * ### Literal
 * Represents a literal value.
 */
async function resolve$5({ node }) {
    return node.value;
}

/**
 * ### ObjectExpression
 * Represents a javascript Object
 */
async function resolve$4({ node, scope, raiseError, ...props }) {
    const resolvedObject = {};
    for (const prop of node.properties) {
        if (prop.type !== 'Property') {
            throw raiseError(errors.invalidObjectKey, node);
        }
        const key = prop.key;
        const value = await resolveLogicNode({
            node: prop.value,
            scope,
            raiseError,
            ...props,
        });
        resolvedObject[key.name] = value;
    }
    return resolvedObject;
}
function isProperty(prop) {
    return prop.type === 'Property';
}
async function readMetadata$5({ node, ...props }) {
    const propertiesMetadata = await Promise.all(node.properties.filter(isProperty).map((prop) => Promise.all([
        getLogicNodeMetadata({
            node: prop.key,
            ...props,
        }),
        getLogicNodeMetadata({
            node: prop.value,
            ...props,
        }),
    ])));
    return mergeMetadata(...propertiesMetadata.flat());
}

/**
 * ### MemberExpression
 * Represents a property from an object. If the property does not exist in the object, it will return undefined.
 */
async function resolve$3({ node, ...props }) {
    const object = await resolveLogicNode({
        node: node.object,
        ...props,
    });
    // Accessing to the property can be optional (?.)
    if (object == null && node.optional)
        return undefined;
    const property = node.computed
        ? await resolveLogicNode({
            node: node.property,
            ...props,
        })
        : node.property.name;
    return MEMBER_EXPRESSION_METHOD(object, property);
}
async function readMetadata$4({ node, ...props }) {
    return mergeMetadata(await getLogicNodeMetadata({
        node: node.object,
        ...props,
    }), node.computed
        ? await getLogicNodeMetadata({ node: node.property, ...props })
        : emptyMetadata());
}

/**
 * ### SequenceExpression
 * Represents a sequence of expressions. It is only used to evaluate ?. operators.
 */
async function resolve$2({ node, ...props }) {
    return await Promise.all(node.expressions.map((expression) => resolveLogicNode({ node: expression, ...props })));
}
async function readMetadata$3({ node, ...props }) {
    const childrenMetadata = await Promise.all(node.expressions.map(async (expression) => getLogicNodeMetadata({ node: expression, ...props })));
    return mergeMetadata(...childrenMetadata);
}

/**
 * ### UnaryExpression
 * Represents a simple operation on a single operand, either as a prefix or suffix.
 *
 * Example: `{!a}`
 */
async function resolve$1({ node, raiseError, ...props }) {
    const unaryOperator = node.operator;
    if (!(unaryOperator in UNARY_OPERATOR_METHODS)) {
        raiseError(errors.unsupportedOperator(unaryOperator), node);
    }
    const unaryArgument = await resolveLogicNode({
        node: node.argument,
        raiseError,
        ...props,
    });
    const unaryPrefix = node.prefix;
    return UNARY_OPERATOR_METHODS[unaryOperator]?.(unaryArgument, unaryPrefix);
}
async function readMetadata$2({ node, ...props }) {
    return await getLogicNodeMetadata({
        node: node.argument,
        ...props,
    });
}

/**
 * ### UpdateExpression
 * Represents a javascript update expression.
 * Depending on the operator, it can increment or decrement a value.
 * Depending on the position of the operator, the return value can be resolved before or after the operation.
 *
 * Examples: `{--foo}` `{bar++}`
 */
async function resolve({ node, scope, raiseError, ...props }) {
    const updateOperator = node.operator;
    if (!['++', '--'].includes(updateOperator)) {
        raiseError(errors.unsupportedOperator(updateOperator), node);
    }
    const assignmentOperators = {
        '++': '+=',
        '--': '-=',
    };
    const originalValue = await resolveLogicNode({
        node: node.argument,
        scope,
        raiseError,
        ...props,
    });
    if (typeof originalValue !== 'number') {
        raiseError(errors.invalidUpdate(updateOperator, typeof originalValue), node);
    }
    // Simulate an AssignmentExpression with the same operation
    const assignmentNode = {
        ...node,
        type: 'AssignmentExpression',
        left: node.argument,
        operator: assignmentOperators[updateOperator],
        right: {
            type: 'Literal',
            value: 1,
        },
    };
    // Perform the assignment
    const updatedValue = await resolveLogicNode({
        node: assignmentNode,
        scope,
        raiseError,
        ...props,
    });
    return node.prefix ? updatedValue : originalValue;
}
async function readMetadata$1({ node, ...props }) {
    return await getLogicNodeMetadata({
        node: node.argument,
        ...props,
    });
}

const nodeResolvers = {
    [NodeType.ArrayExpression]: resolve$c,
    [NodeType.AssignmentExpression]: resolve$b,
    [NodeType.BinaryExpression]: resolve$8,
    [NodeType.CallExpression]: resolve$9,
    [NodeType.ChainExpression]: resolve$a,
    [NodeType.ConditionalExpression]: resolve$7,
    [NodeType.Identifier]: resolve$6,
    [NodeType.Literal]: resolve$5,
    [NodeType.LogicalExpression]: resolve$8,
    [NodeType.ObjectExpression]: resolve$4,
    [NodeType.MemberExpression]: resolve$3,
    [NodeType.SequenceExpression]: resolve$2,
    [NodeType.UnaryExpression]: resolve$1,
    [NodeType.UpdateExpression]: resolve,
};
const nodeMetadataReader = {
    [NodeType.Identifier]: async () => emptyMetadata(), // No metadata to read
    [NodeType.Literal]: async () => emptyMetadata(), // No metadata to read
    [NodeType.ArrayExpression]: readMetadata$b,
    [NodeType.AssignmentExpression]: readMetadata$a,
    [NodeType.BinaryExpression]: readMetadata$7,
    [NodeType.CallExpression]: readMetadata$8,
    [NodeType.ChainExpression]: readMetadata$9,
    [NodeType.ConditionalExpression]: readMetadata$6,
    [NodeType.LogicalExpression]: readMetadata$7,
    [NodeType.ObjectExpression]: readMetadata$5,
    [NodeType.MemberExpression]: readMetadata$4,
    [NodeType.SequenceExpression]: readMetadata$3,
    [NodeType.UnaryExpression]: readMetadata$2,
    [NodeType.UpdateExpression]: readMetadata$1,
};

/**
 * Given a node, calculates the resulting value.
 */
async function resolveLogicNode(props) {
    const type = props.node.type;
    if (!nodeResolvers[type]) {
        throw new Error(`Unknown node type: ${type}`);
    }
    const nodeResolver = nodeResolvers[props.node.type];
    return nodeResolver(props);
}
/**
 * Given a node, extracts the supported methods that are being invoked.
 */
async function getLogicNodeMetadata(props) {
    const type = props.node.type;
    if (!nodeMetadataReader[type]) {
        throw new Error(`Unknown node type: ${type}`);
    }
    const methodExtractor = nodeMetadataReader[props.node.type];
    return methodExtractor(props);
}

class Compiler {
    context;
    currentConfig = {};
    constructor({ sql, supportedMethods = {}, resolveFn }) {
        this.context = { sql, supportedMethods, resolveFn };
    }
    /**
     * Resolves every block, expression, and function inside the SQL and returns the final query.
     *
     * Note: Compiling a query may take time in some cases, as some queries may contain expensive
     * functions that need to be resolved at runtime.
     */
    async compileSQL() {
        const fragment = parse(this.context.sql);
        const localScope = new Scope();
        const compiledSql = (await this.resolveBaseNode(fragment, localScope, 0))
            .replace(/ +/g, ' ') // Remove extra spaces
            .trim(); // Remove leading and trailing spaces
        return compiledSql;
    }
    /**
     * Without compiling the SQL or resolving any expression, quickly reads the config and calls
     * to the supported methods present in the SQL.
     */
    async readMetadata() {
        const fragment = parse(this.context.sql);
        const rawSql = this.context.sql;
        const sqlHash = createHash('sha256').update(rawSql).digest('hex');
        const baseMetadata = await this.getBaseNodeMetadata({
            baseNode: fragment,
            depth: 0,
        });
        return mergeMetadata(baseMetadata, { ...emptyMetadata(), sqlHash, rawSql });
    }
    /**
     * Given a base node, returns the string that will replace it in the final SQL
     */
    resolveBaseNode = async (baseNode, localScope, depth) => {
        if (!baseNode)
            return '';
        if (baseNode.type === 'Fragment') {
            // Parent node, only one of its kind
            return this.resolveBaseNodeChildren(baseNode.children, localScope, depth);
        }
        if (baseNode.type === 'Comment') {
            return baseNode.raw;
        }
        if (baseNode.type === 'Text') {
            return baseNode.raw;
        }
        if (baseNode.type === 'MustacheTag') {
            const expression = baseNode.expression;
            // Some node expressions do not inject any value into the SQL
            const silentExpressions = [NodeType.AssignmentExpression];
            if (silentExpressions.includes(expression.type)) {
                await resolveLogicNode({
                    node: expression,
                    scope: localScope,
                    raiseError: this.expressionError.bind(this),
                    supportedMethods: this.context.supportedMethods,
                    willInterpolate: false,
                    resolveFn: this.context.resolveFn,
                });
                return '';
            }
            if (
            // If the expression is a call to a supported method, the result WILL BE INTERPOLATED
            expression.type === NodeType.CallExpression &&
                expression.callee.type === NodeType.Identifier &&
                expression.callee.name in this.context.supportedMethods) {
                return (await resolveLogicNode({
                    node: expression,
                    scope: localScope,
                    raiseError: this.expressionError.bind(this),
                    supportedMethods: this.context.supportedMethods,
                    willInterpolate: true,
                    resolveFn: this.context.resolveFn,
                }));
            }
            const value = await resolveLogicNode({
                node: expression,
                scope: localScope,
                raiseError: this.expressionError.bind(this),
                supportedMethods: this.context.supportedMethods,
                willInterpolate: false,
                resolveFn: this.context.resolveFn,
            });
            const resolvedValue = await this.context.resolveFn(value);
            return resolvedValue;
        }
        if (baseNode.type === 'ConstTag') {
            // Only allow equal expressions to define constants
            const expression = baseNode.expression;
            if (expression.type !== 'AssignmentExpression' ||
                expression.operator !== '=' ||
                expression.left.type !== 'Identifier') {
                this.baseNodeError(errors.invalidConstantDefinition, baseNode);
            }
            const constName = expression.left.name;
            const constValue = await resolveLogicNode({
                node: expression.right,
                scope: localScope,
                raiseError: this.expressionError.bind(this),
                supportedMethods: this.context.supportedMethods,
                willInterpolate: false,
                resolveFn: this.context.resolveFn,
            });
            if (localScope.exists(constName)) {
                this.baseNodeError(errors.variableAlreadyDeclared(constName), baseNode);
            }
            localScope.defineConst(constName, constValue);
            return '';
        }
        if (baseNode.type === 'ConfigTag') {
            if (depth > 0) {
                this.baseNodeError(errors.configInsideBlock, baseNode);
            }
            const expression = baseNode.expression;
            if (expression.type !== 'AssignmentExpression' ||
                expression.operator !== '=' ||
                expression.left.type !== 'Identifier') {
                this.baseNodeError(errors.invalidConfigDefinition, baseNode);
            }
            if (expression.right.type !== 'Literal') {
                this.baseNodeError(errors.invalidConfigValue, baseNode);
            }
            return '';
        }
        if (baseNode.type === 'IfBlock') {
            const condition = await resolveLogicNode({
                node: baseNode.expression,
                scope: localScope,
                raiseError: this.expressionError.bind(this),
                supportedMethods: this.context.supportedMethods,
                willInterpolate: false,
                resolveFn: this.context.resolveFn,
            });
            return condition
                ? this.resolveBaseNodeChildren(baseNode.children, localScope, depth + 1)
                : await this.resolveBaseNode(baseNode.else, localScope, depth + 1);
        }
        if (baseNode.type === 'ElseBlock') {
            return this.resolveBaseNodeChildren(baseNode.children, localScope, depth + 1);
        }
        if (baseNode.type === 'EachBlock') {
            const iterableElement = await resolveLogicNode({
                node: baseNode.expression,
                scope: localScope,
                raiseError: this.expressionError.bind(this),
                supportedMethods: this.context.supportedMethods,
                willInterpolate: false,
                resolveFn: this.context.resolveFn,
            });
            if (!Array.isArray(iterableElement) || !iterableElement.length) {
                return await this.resolveBaseNode(baseNode.else, localScope, depth + 1);
            }
            const contextVar = baseNode.context.name;
            const indexVar = baseNode.index;
            if (localScope.exists(contextVar)) {
                this.baseNodeError(errors.variableAlreadyDeclared(contextVar), baseNode);
            }
            if (indexVar && localScope.exists(indexVar)) {
                this.baseNodeError(errors.variableAlreadyDeclared(indexVar), baseNode);
            }
            const parsedChildren = [];
            for (let i = 0; i < iterableElement.length; i++) {
                const element = iterableElement[i];
                if (indexVar)
                    localScope.set(indexVar, i);
                localScope.set(contextVar, element);
                parsedChildren.push(await this.resolveBaseNodeChildren(baseNode.children, localScope, depth + 1));
            }
            return parsedChildren.join('') || '';
        }
        throw this.baseNodeError(errors.unsupportedBaseNodeType(baseNode.type), baseNode);
    };
    resolveBaseNodeChildren = async (children, localScope, depth) => {
        const parsedChildren = [];
        const childrenScope = localScope.copy(); // All children share the same scope
        for (const child of children || []) {
            const parsedChild = await this.resolveBaseNode(child, childrenScope, depth);
            parsedChildren.push(parsedChild);
        }
        return parsedChildren.join('') || '';
    };
    /**
     * Given a base node, returns the list of defined configs and present methods from the supportedMethods.
     */
    getBaseNodeMetadata = async ({ baseNode, depth, }) => {
        if (!baseNode)
            return emptyMetadata();
        if (baseNode.type === 'Fragment') {
            const childrenMetadata = await Promise.all((baseNode.children || []).map((child) => this.getBaseNodeMetadata({
                baseNode: child,
                depth,
            })));
            return mergeMetadata(...childrenMetadata);
        }
        // Not computed nodes. Do not contain any configs or methods
        if (['Comment', 'Text'].includes(baseNode.type)) {
            return emptyMetadata();
        }
        if (baseNode.type === 'MustacheTag') {
            const expression = baseNode.expression;
            return await getLogicNodeMetadata({
                node: expression,
                supportedMethods: this.context.supportedMethods,
            });
        }
        if (baseNode.type === 'ConstTag') {
            // Only allow equal expressions to define constants
            const expression = baseNode.expression;
            return await getLogicNodeMetadata({
                node: expression,
                supportedMethods: this.context.supportedMethods,
            });
        }
        if (baseNode.type === 'ConfigTag') {
            if (depth > 0) {
                this.baseNodeError(errors.configInsideBlock, baseNode);
            }
            const expression = baseNode.expression;
            if (expression.type !== 'AssignmentExpression' ||
                expression.operator !== '=' ||
                expression.left.type !== 'Identifier') {
                this.baseNodeError(errors.invalidConfigDefinition, baseNode);
            }
            if (expression.right.type !== 'Literal') {
                this.baseNodeError(errors.invalidConfigValue, baseNode);
            }
            const configName = expression.left.name;
            const configValue = expression.right.value;
            if (configName in this.currentConfig) {
                this.baseNodeError(errors.configAlreadyDefined(configName), baseNode);
            }
            this.currentConfig[configName] = configValue;
            return {
                ...emptyMetadata(),
                config: {
                    [configName]: configValue,
                },
            };
        }
        if (baseNode.type === 'IfBlock' || baseNode.type === 'EachBlock') {
            const expression = baseNode.expression;
            const conditionMetadata = await getLogicNodeMetadata({
                node: expression,
                supportedMethods: this.context.supportedMethods,
            });
            const elseMetadata = await this.getBaseNodeMetadata({
                baseNode: baseNode.else,
                depth: depth + 1,
            });
            const childrenMetadata = await Promise.all((baseNode.children || []).map((child) => this.getBaseNodeMetadata({
                baseNode: child,
                depth: depth + 1,
            })));
            return mergeMetadata(conditionMetadata, elseMetadata, ...childrenMetadata);
        }
        if (baseNode.type === 'ElseBlock') {
            const childrenMetadata = await Promise.all((baseNode.children || []).map((child) => this.getBaseNodeMetadata({
                baseNode: child,
                depth: depth + 1,
            })));
            return mergeMetadata(...childrenMetadata);
        }
        throw this.baseNodeError(errors.unsupportedBaseNodeType(baseNode.type), baseNode);
    };
    baseNodeError({ code, message }, node) {
        error(message, {
            name: 'CompileError',
            code,
            source: this.context.sql || '',
            start: node.start || 0,
            end: node.end || undefined,
        });
    }
    expressionError({ code, message }, node) {
        const source = (node.loc?.source ?? this.context.sql).split('\n');
        const start = source
            .slice(0, node.loc?.start.line - 1)
            .reduce((acc, line) => acc + line.length + 1, 0) +
            node.loc?.start.column;
        const end = source
            .slice(0, node.loc?.end.line - 1)
            .reduce((acc, line) => acc + line.length + 1, 0) + node.loc?.end.column;
        error(message, {
            name: 'CompileError',
            code,
            source: this.context.sql || '',
            start,
            end,
        });
    }
}

function compile({ query, supportedMethods, resolveFn, }) {
    return new Compiler({
        sql: query,
        supportedMethods: supportedMethods || {},
        resolveFn,
    }).compileSQL();
}
function readMetadata({ query, supportedMethods, }) {
    return new Compiler({
        sql: query,
        supportedMethods: supportedMethods || {},
        resolveFn: () => Promise.resolve(''),
    }).readMetadata();
}

export { CompileError, compile, emptyMetadata, mergeMetadata, readMetadata };
//# sourceMappingURL=index.js.map
