{"version":3,"file":"index.js","sources":["../src/error/error.ts","../src/error/errors.ts","../src/parser/utils/full_char_code_at.ts","../src/utils/names.ts","../src/parser/state/dash_comment.ts","../src/parser/state/multi_line_comment.ts","../src/parser/utils/acorn.ts","../src/parser/read/expression.ts","../src/parser/utils/bracket.ts","../src/parser/read/context.ts","../src/parser/state/mustache.ts","../src/parser/state/text.ts","../src/parser/state/fragment.ts","../src/parser/index.ts","../src/compiler/scope.ts","../src/compiler/logic/types.ts","../src/compiler/utils.ts","../src/compiler/logic/nodes/arrayExpression.ts","../src/compiler/logic/operators.ts","../src/compiler/logic/nodes/assignmentExpression.ts","../src/compiler/logic/nodes/chainExpression.ts","../src/compiler/logic/nodes/callExpression.ts","../src/compiler/logic/nodes/binaryExpression.ts","../src/compiler/logic/nodes/conditionalExpression.ts","../src/compiler/logic/nodes/identifier.ts","../src/compiler/logic/nodes/literal.ts","../src/compiler/logic/nodes/objectExpression.ts","../src/compiler/logic/nodes/memberExpression.ts","../src/compiler/logic/nodes/sequenceExpression.ts","../src/compiler/logic/nodes/unaryExpression.ts","../src/compiler/logic/nodes/updateExpression.ts","../src/compiler/logic/nodes/index.ts","../src/compiler/logic/index.ts","../src/compiler/index.ts","../src/index.ts"],"sourcesContent":["import { locate } from 'locate-character'\n\nexport interface Position {\n  line: number\n  column: number\n}\n\ntype CompileErrorProps = {\n  name: string\n  code: string\n  source: string\n  start: number\n  end?: number\n}\n\nexport default class CompileError extends Error {\n  code?: string\n  start?: Position\n  end?: Position\n  pos?: number\n  frame?: string\n\n  toString() {\n    if (!this.start) return this.message\n    return `${this.message} (${this.start.line}:${this.start.column})\\n${this.frame}`\n  }\n}\n\nfunction tabsToSpaces(str: string) {\n  return str.replace(/^\\t+/, (match) => match.split('\\t').join('  '))\n}\n\nfunction getCodeFrame(\n  source: string,\n  line: number,\n  startColumn: number,\n  endColumn: number | undefined,\n): string {\n  const lines = source.split('\\n')\n  const frameStart = Math.max(0, line - 2)\n  const frameEnd = Math.min(line + 3, lines.length)\n  const digits = String(frameEnd + 1).length\n  return lines\n    .slice(frameStart, frameEnd)\n    .map((str, i) => {\n      const isErrorLine = frameStart + i === line\n      const lineNum = String(i + frameStart + 1).padStart(digits, ' ')\n      if (isErrorLine) {\n        const indicator =\n          ' '.repeat(\n            digits + 2 + tabsToSpaces(str.slice(0, startColumn)).length,\n          ) +\n          '^' +\n          '~'.repeat(endColumn ? Math.max(0, endColumn - startColumn - 1) : 0)\n        return `${lineNum}: ${tabsToSpaces(str)}\\n\\n${indicator}`\n      }\n      return `${lineNum}: ${tabsToSpaces(str)}`\n    })\n    .join('\\n')\n}\n\nexport function error(message: string, props: CompileErrorProps): never {\n  const error = new CompileError(message)\n  error.name = props.name\n  const start = locate(props.source, props.start, { offsetLine: 1 })\n  const end = locate(props.source, props.end || props.start, { offsetLine: 1 })\n  error.code = props.code\n  error.start = start\n  error.end = end\n  error.pos = props.start\n  error.frame = getCodeFrame(\n    props.source,\n    (start?.line ?? 1) - 1,\n    start?.column ?? 0,\n    end?.column,\n  )\n  throw error\n}\n","function getKlassName(error: unknown): string {\n  const errorKlass = error as Error\n  return errorKlass.constructor ? errorKlass.constructor.name : 'Error'\n}\n\nexport default {\n  unexpectedEof: {\n    code: 'unexpected-eof',\n    message: 'Unexpected end of input',\n  },\n  unexpectedEofToken: (token: string) => ({\n    code: 'unexpected-eof',\n    message: `Unexpected '${token}'`,\n  }),\n  unexpectedToken: (token: string) => ({\n    code: 'unexpected-token',\n    message: `Expected '${token}'`,\n  }),\n  unexpectedBlockClose: {\n    code: 'unexpected-block-close',\n    message: 'Unexpected block closing tag',\n  },\n  invalidElseif: {\n    code: 'invalid-elseif',\n    message: \"'elseif' should be 'else if'\",\n  },\n  invalidElseifPlacementUnclosedBlock: (block: string) => ({\n    code: 'invalid-elseif-placement',\n    message: `Expected to close ${block} before seeing {:else if ...} block`,\n  }),\n  invalidElseifPlacementOutsideIf: {\n    code: 'invalid-elseif-placement',\n    message: 'Cannot have an {:else if ...} block outside an {#if ...} block',\n  },\n  invalidElsePlacementUnclosedBlock: (block: string) => ({\n    code: 'invalid-else-placement',\n    message: `Expected to close ${block} before seeing {:else} block`,\n  }),\n  invalidElsePlacementOutsideIf: {\n    code: 'invalid-else-placement',\n    message:\n      'Cannot have an {:else} block outside an {#if ...} or {#each ...} block',\n  },\n  expectedBlockType: {\n    code: 'expected-block-type',\n    message: 'Expected if or each',\n  },\n  unexpectedTokenDestructure: {\n    code: 'unexpected-token',\n    message: 'Expected identifier or destructure pattern',\n  },\n  expectedName: {\n    code: 'expected-name',\n    message: 'Expected name',\n  },\n  unexpectedMustacheCloseTag: {\n    code: 'unexpected-mustache-close-tag',\n    message: 'Unexpected closing tag without matching opening tag',\n  },\n  unexpectedEndOfComment: {\n    code: 'unexpected-end-of-comment',\n    message: 'Unexpected end of comment',\n  },\n\n  // Compiler errors:\n  queryNotFound: (name: string) => ({\n    code: 'query-not-found',\n    message: `Query '${name}' not found`,\n  }),\n  unsupportedBaseNodeType: (type: string) => ({\n    code: 'unsupported-base-node-type',\n    message: `Unsupported base node type: ${type}`,\n  }),\n  unsupportedExpressionType: (type: string) => ({\n    code: 'unsupported-expression-type',\n    message: `Unsupported expression type: ${type}`,\n  }),\n  invalidConstantDefinition: {\n    code: 'invalid-constant-definition',\n    message: 'Constant definitions must assign a value to a variable',\n  },\n  invalidConfigDefinition: {\n    code: 'invalid-config-definition',\n    message: 'Config definitions must assign a value to an option',\n  },\n  invalidConfigValue: {\n    code: 'invalid-config-value',\n    message:\n      'Config values must be literals. Cannot use variables or expressions',\n  },\n  configInsideBlock: {\n    code: 'config-inside-block',\n    message: 'Cannot must be defined at root level. Cannot be inside a block',\n  },\n  configDefinitionFailed: (name: string, message: string) => ({\n    code: 'config-definition-failed',\n    message: `Config definition for '${name}' failed: ${message}`,\n  }),\n  configAlreadyDefined: (name: string) => ({\n    code: 'config-already-defined',\n    message: `Config definition for '${name}' failed: Option already configured`,\n  }),\n  variableAlreadyDeclared: (name: string) => ({\n    code: 'variable-already-declared',\n    message: `Variable '${name}' is already declared`,\n  }),\n  variableNotDeclared: (name: string) => ({\n    code: 'variable-not-declared',\n    message: `Variable '${name}' is not declared`,\n  }),\n  invalidObjectKey: {\n    code: 'invalid-object-key',\n    message: 'Invalid object key',\n  },\n  unsupportedOperator: (operator: string) => ({\n    code: 'unsupported-operator',\n    message: `Unsupported operator: ${operator}`,\n  }),\n  constantReassignment: {\n    code: 'constant-reassignment',\n    message: 'Cannot reassign a constant',\n  },\n  invalidAssignment: {\n    code: 'invalid-assignment',\n    message: 'Invalid assignment',\n  },\n  invalidUpdate: (operation: string, type: string) => ({\n    code: 'invalid-update',\n    message: `Cannot use ${operation} operation on ${type}`,\n  }),\n\n  propertyNotExists: (property: string) => ({\n    code: 'property-not-exists',\n    message: `Property '${property}' does not exist on object`,\n  }),\n  unknownFunction: (name: string) => ({\n    code: 'unknown-function',\n    message: `Unknown function: ${name}`,\n  }),\n  notAFunction: (objectType: string) => ({\n    code: 'not-a-function',\n    message: `Object '${objectType}' is callable`,\n  }),\n  functionCallError: (err: unknown) => {\n    const error = err as Error\n    const errorKlassName = getKlassName(error)\n    return {\n      code: 'function-call-error',\n      message: `Error calling function: \\n${errorKlassName} ${error.message}`,\n    }\n  },\n  functionRequiresStaticArguments: (name: string) => ({\n    code: 'function-requires-static-arguments',\n    message: `Function '${name}' can only receive literal values as arguments`,\n  }),\n  functionRequiresInterpolation: (name: string) => ({\n    code: 'function-requires-interpolation',\n    message: `Function '${name}' cannot be used inside a logic block. It must be directly interpolated into the query`,\n  }),\n  functionDisallowsInterpolation: (name: string) => ({\n    code: 'function-disallows-interpolation',\n    message: `Function '${name}' cannot be directly interpolated into the query`,\n  }),\n  invalidFunctionResultInterpolation: {\n    code: 'invalid-function-result-interpolation',\n    message: 'Functions called for interpolation must return a string',\n  },\n}\n","// Adapted from https://github.com/acornjs/acorn/blob/6584815dca7440e00de841d1dad152302fdd7ca5/src/tokenize.js\n\nexport default function fullCharCodeAt(str: string, i: number): number {\n  const code = str.charCodeAt(i)\n  if (code <= 0xd7ff || code >= 0xe000) return code\n\n  const next = str.charCodeAt(i + 1)\n  return (code << 10) + next - 0x35fdc00\n}\n","export const reserved = new Set([\n  'arguments',\n  'await',\n  'break',\n  'case',\n  'catch',\n  'class',\n  'const',\n  'continue',\n  'debugger',\n  'default',\n  'delete',\n  'do',\n  'else',\n  'enum',\n  'eval',\n  'export',\n  'extends',\n  'false',\n  'finally',\n  'for',\n  'function',\n  'if',\n  'implements',\n  'import',\n  'in',\n  'instanceof',\n  'interface',\n  'let',\n  'new',\n  'null',\n  'package',\n  'private',\n  'protected',\n  'public',\n  'return',\n  'static',\n  'super',\n  'switch',\n  'this',\n  'throw',\n  'true',\n  'try',\n  'typeof',\n  'var',\n  'void',\n  'while',\n  'with',\n  'yield',\n])\n","import { Parser } from '..'\n\nexport function dashComment(parser: Parser) {\n  const start = parser.index\n\n  let data = ''\n\n  while (parser.index < parser.template.length) {\n    if (parser.matchRegex(/\\n/)) {\n      break\n    }\n    data += parser.template[parser.index++]\n  }\n\n  const node = {\n    start,\n    end: parser.index,\n    type: 'Comment',\n    raw: data,\n    data: data.substring(2),\n  }\n\n  parser.current().children!.push(node)\n}\n","import { Parser } from '..'\nimport PARSER_ERRORS from '../../error/errors'\n\nexport function multiLineComment(parser: Parser) {\n  if (parser.match('*/')) {\n    parser.error(PARSER_ERRORS.unexpectedEndOfComment)\n  }\n\n  const start = parser.index\n\n  while (parser.index < parser.template.length) {\n    if (parser.matchRegex(/\\*\\//)) {\n      parser.index += 2\n      break\n    }\n    parser.index++\n  }\n\n  const data = parser.template.substring(start, parser.index)\n\n  const node = {\n    start,\n    end: parser.index + 1,\n    type: 'Comment',\n    raw: data,\n    data: data.substring(2, data.length - 2),\n  }\n\n  parser.current().children!.push(node)\n}\n","import * as code_red from 'code-red'\n\nexport const parse = (source: string) =>\n  code_red.parse(source, {\n    sourceType: 'module',\n    ecmaVersion: 13,\n    locations: true,\n  })\n\nexport const parseExpressionAt = (source: string, index: number) =>\n  code_red.parseExpressionAt(source, index, {\n    sourceType: 'module',\n    ecmaVersion: 13,\n    locations: true,\n  })\n","import { Parser } from '..'\nimport { parseExpressionAt } from '../utils/acorn'\nimport PARSER_ERRORS from '../../error/errors'\nimport CompileError from '../../error/error'\n\nexport default function readExpression(parser: Parser) {\n  try {\n    const node = parseExpressionAt(parser.template, parser.index)\n\n    let numParenthesis = 0\n\n    for (let i = parser.index; i < node.start; i += 1) {\n      if (parser.template[i] === '(') numParenthesis += 1\n    }\n\n    let index = node.end\n    while (numParenthesis > 0) {\n      const char = parser.template[index]\n\n      if (char === ')') {\n        numParenthesis -= 1\n      } else if (!/\\s/.test(char!)) {\n        parser.error(PARSER_ERRORS.unexpectedToken(')'), index)\n      }\n\n      index += 1\n    }\n\n    parser.index = index\n\n    return node\n  } catch (err) {\n    parser.acornError(err as CompileError)\n  }\n}\n","const SQUARE_BRACKET_OPEN = '['.charCodeAt(0)\nconst SQUARE_BRACKET_CLOSE = ']'.charCodeAt(0)\nconst CURLY_BRACKET_OPEN = '{'.charCodeAt(0)\nconst CURLY_BRACKET_CLOSE = '}'.charCodeAt(0)\n\nexport function isBracketOpen(code: number) {\n  return code === SQUARE_BRACKET_OPEN || code === CURLY_BRACKET_OPEN\n}\n\nexport function isBracketClose(code: number) {\n  return code === SQUARE_BRACKET_CLOSE || code === CURLY_BRACKET_CLOSE\n}\n\nexport function isBracketPair(open: number, close: number) {\n  return (\n    (open === SQUARE_BRACKET_OPEN && close === SQUARE_BRACKET_CLOSE) ||\n    (open === CURLY_BRACKET_OPEN && close === CURLY_BRACKET_CLOSE)\n  )\n}\n\nexport function getBracketClose(open: number): number | undefined {\n  if (open === SQUARE_BRACKET_OPEN) {\n    return SQUARE_BRACKET_CLOSE\n  }\n  if (open === CURLY_BRACKET_OPEN) {\n    return CURLY_BRACKET_CLOSE\n  }\n}\n","// @ts-expect-error - no types for this package\nimport { isIdentifierStart } from 'acorn'\nimport fullCharCodeAt from '../utils/full_char_code_at'\nimport {\n  isBracketOpen,\n  isBracketClose,\n  isBracketPair,\n  getBracketClose,\n} from '../utils/bracket'\nimport { parseExpressionAt } from '../utils/acorn'\nimport PARSER_ERRORS from '../../error/errors'\nimport { Parser } from '..'\nimport type CompileError from '../../error/error'\nimport { Pattern } from 'estree'\n\nexport default function readContext(\n  parser: Parser,\n): Pattern & { start: number; end: number } {\n  const start = parser.index\n  let i = parser.index\n\n  const code = fullCharCodeAt(parser.template, i)\n  if (isIdentifierStart(code, true)) {\n    return {\n      type: 'Identifier',\n      name: parser.readIdentifier()!,\n      start,\n      end: parser.index,\n    }\n  }\n\n  if (!isBracketOpen(code)) {\n    parser.error(PARSER_ERRORS.unexpectedTokenDestructure)\n  }\n\n  const bracketStack: number[] = [code]\n  i += code <= 0xffff ? 1 : 2\n\n  while (i < parser.template.length) {\n    const code = fullCharCodeAt(parser.template, i)\n    if (isBracketOpen(code)) {\n      bracketStack.push(code)\n    } else if (isBracketClose(code)) {\n      if (!isBracketPair(bracketStack[bracketStack.length - 1]!, code)) {\n        parser.error(\n          PARSER_ERRORS.unexpectedToken(\n            String.fromCharCode(\n              getBracketClose(bracketStack[bracketStack.length - 1]!) ?? 0,\n            ),\n          ),\n        )\n      }\n      bracketStack.pop()\n      if (bracketStack.length === 0) {\n        i += code <= 0xffff ? 1 : 2\n        break\n      }\n    }\n    i += code <= 0xffff ? 1 : 2\n  }\n\n  parser.index = i\n\n  const patternString = parser.template.slice(start, i)\n  try {\n    // the length of the `space_with_newline` has to be start - 1\n    // because we added a `(` in front of the pattern_string,\n    // which shifted the entire string to right by 1\n    // so we offset it by removing 1 character in the `space_with_newline`\n    // to achieve that, we remove the 1st space encountered,\n    // so it will not affect the `column` of the node\n    let spaceWithNewLine = parser.template\n      .slice(0, start)\n      .replace(/[^\\n]/g, ' ')\n    const firstSpace = spaceWithNewLine.indexOf(' ')\n    spaceWithNewLine =\n      spaceWithNewLine.slice(0, firstSpace) +\n      spaceWithNewLine.slice(firstSpace + 1)\n\n    return parseExpressionAt(\n      `${spaceWithNewLine}(${patternString} = 1)`,\n      start - 1,\n    ).left\n  } catch (error) {\n    parser.acornError(error as CompileError)\n  }\n\n  return {\n    type: 'Identifier',\n    name: '',\n    start: parser.index,\n    end: parser.index,\n  }\n}\n","import { type Parser } from '..'\nimport PARSER_ERRORS from '../../error/errors'\nimport { type TemplateNode } from '../interfaces'\nimport readExpression from '../read/expression'\nimport readContext from '../read/context'\n\nexport function mustache(parser: Parser) {\n  if (parser.match('}')) {\n    parser.error(PARSER_ERRORS.unexpectedMustacheCloseTag)\n  }\n  const start = parser.index\n  parser.index += 1\n  parser.allowWhitespace()\n  // {/if}, {/each}, {/await} or {/key}\n  if (parser.eat('/')) {\n    let block = parser.current()\n    let expected: string\n    if (block.type === 'ElseBlock') {\n      block.end = start\n      parser.stack.pop()\n      block = parser.current()\n      expected = 'else'\n    }\n    if (block.type === 'IfBlock') {\n      expected = 'if'\n    } else if (block.type === 'EachBlock') {\n      expected = 'each'\n    } else {\n      parser.error(PARSER_ERRORS.unexpectedBlockClose)\n    }\n    parser.eat(expected!, true)\n    parser.allowWhitespace()\n    parser.eat('}', true)\n    while (block.elseif) {\n      block.end = parser.index\n      parser.stack.pop()\n      block = parser.current()\n      if (block.else) {\n        block.else.end = start\n      }\n    }\n    // strip leading/trailing whitespace as necessary\n    const charBefore = parser.template[block.start! - 1]\n    const charAfter = parser.template[parser.index]\n    const trimBefore = !charBefore || /\\s/.test(charBefore)\n    const trimAfter = !charAfter || /\\s/.test(charAfter)\n    trimWhitespace(block, trimBefore, trimAfter)\n    block.end = parser.index\n    parser.stack.pop()\n  } else if (parser.eat(':else')) {\n    if (parser.eat('if')) {\n      parser.error(PARSER_ERRORS.invalidElseif)\n    }\n    parser.allowWhitespace()\n    // :else if\n    if (parser.eat('if')) {\n      const block = parser.current()\n      if (block.type !== 'IfBlock') {\n        parser.error(\n          parser.stack.some((block) => block.type === 'IfBlock')\n            ? PARSER_ERRORS.invalidElseifPlacementUnclosedBlock(toString(block))\n            : PARSER_ERRORS.invalidElseifPlacementOutsideIf,\n        )\n      }\n      parser.requireWhitespace()\n      const expression = readExpression(parser)\n      parser.allowWhitespace()\n      parser.eat('}', true)\n      block.else = {\n        start: parser.index,\n        end: null,\n        type: 'ElseBlock',\n        children: [\n          {\n            start: parser.index,\n            end: null,\n            type: 'IfBlock',\n            elseif: true,\n            expression,\n            children: [],\n          },\n        ],\n      }\n      parser.stack.push(block.else.children[0])\n    } else {\n      // :else\n      const block = parser.current()\n      if (block.type !== 'IfBlock' && block.type !== 'EachBlock') {\n        parser.error(\n          parser.stack.some(\n            (block) => block.type === 'IfBlock' || block.type === 'EachBlock',\n          )\n            ? PARSER_ERRORS.invalidElsePlacementUnclosedBlock(toString(block))\n            : PARSER_ERRORS.invalidElsePlacementOutsideIf,\n        )\n      }\n      parser.allowWhitespace()\n      parser.eat('}', true)\n      block.else = {\n        start: parser.index,\n        end: null,\n        type: 'ElseBlock',\n        children: [],\n      }\n      parser.stack.push(block.else)\n    }\n  } else if (parser.eat('#')) {\n    // {#if foo}, {#each foo} or {#await foo}\n    const isIf = parser.eat('if')\n    const isEach = parser.eat('each')\n    if (!isIf && !isEach) {\n      parser.error(PARSER_ERRORS.expectedBlockType)\n    }\n    const type = isIf ? 'IfBlock' : 'EachBlock'\n    parser.requireWhitespace()\n    const expression = readExpression(parser)\n    const block: TemplateNode = {\n      start,\n      end: start,\n      type,\n      expression,\n      children: [],\n    }\n    parser.allowWhitespace()\n    // {#each} blocks must declare a context – {#each list as item}\n    if (type === 'EachBlock') {\n      parser.eat('as', true)\n      parser.requireWhitespace()\n      block['context'] = readContext(parser)\n      parser.allowWhitespace()\n      if (parser.eat(',')) {\n        parser.allowWhitespace()\n        block.index = parser.readIdentifier()\n        if (!block.index) parser.error(PARSER_ERRORS.expectedName)\n        parser.allowWhitespace()\n      }\n      if (parser.eat('(')) {\n        parser.allowWhitespace()\n        block.key = readExpression(parser)\n        parser.allowWhitespace()\n        parser.eat(')', true)\n        parser.allowWhitespace()\n      }\n    }\n    parser.eat('}', true)\n    parser.current().children!.push(block)\n    parser.stack.push(block)\n  } else if (parser.eat('@const')) {\n    // {@const a = b}\n    parser.requireWhitespace()\n    const expression = readExpression(parser)\n    if (\n      !(\n        expression.type === 'AssignmentExpression' &&\n        expression.operator === '='\n      )\n    ) {\n      parser.error(\n        {\n          code: 'invalid-const-args',\n          message: '{@const ...} must be an assignment.',\n        },\n        start,\n      )\n    }\n    parser.allowWhitespace()\n    parser.eat('}', true)\n    parser.current().children!.push({\n      start,\n      end: parser.index,\n      type: 'ConstTag',\n      expression,\n    })\n  } else if (parser.eat('@config')) {\n    // {@config a = b}\n    parser.requireWhitespace()\n    const expression = readExpression(parser)\n    if (\n      !(\n        expression.type === 'AssignmentExpression' &&\n        expression.operator === '='\n      )\n    ) {\n      parser.error(\n        {\n          code: 'invalid-config-args',\n          message: '{@config ...} must be an assignment.',\n        },\n        start,\n      )\n    }\n    parser.allowWhitespace()\n    parser.eat('}', true)\n    parser.current().children!.push({\n      start,\n      end: parser.index,\n      type: 'ConfigTag',\n      expression,\n    })\n  } else {\n    const expression = readExpression(parser)\n    parser.allowWhitespace()\n    parser.eat('}', true)\n    parser.current().children!.push({\n      start,\n      end: parser.index,\n      type: 'MustacheTag',\n      expression,\n    })\n  }\n}\n\nfunction trimWhitespace(\n  block: TemplateNode,\n  trimBefore: boolean = false,\n  trimAfter: boolean = false,\n) {\n  if (!block.children || block.children.length === 0) return // AwaitBlock\n  const firstChild = block.children[0]!\n  const lastChild = block.children[block.children.length - 1]!\n  if (firstChild.type === 'Text' && trimBefore) {\n    firstChild.data = firstChild.data.replace(/^[ \\t\\r\\n]*/, '')\n    if (!firstChild.data) block.children.shift()\n  }\n  if (lastChild.type === 'Text' && trimAfter) {\n    lastChild.data = lastChild.data.replace(/[ \\t\\r\\n]*$/, '')\n    if (!lastChild.data) block.children.pop()\n  }\n  if (block.else) {\n    trimWhitespace(block.else, trimBefore, trimAfter)\n  }\n  if (firstChild.elseif) {\n    trimWhitespace(firstChild, trimBefore, trimAfter)\n  }\n}\n\nfunction toString(node: TemplateNode) {\n  switch (node.type) {\n    case 'IfBlock':\n      return '{#if} block'\n    case 'ElseBlock':\n      return '{:else} block'\n    case 'EachBlock':\n      return '{#each} block'\n    case 'ConstTag':\n      return '{@const} tag'\n    case 'ConfigTag':\n      return '{@config} tag'\n    default:\n      return node.type\n  }\n}\n","import { type Parser } from '..'\n\nconst STRING_DELIMITERS_REGEX = /['\"`]/\nfunction textInString(parser: Parser, char: string): string {\n  let data = ''\n\n  while (parser.index < parser.template.length) {\n    if (\n      parser.match(char) &&\n      !parser.match(char.repeat(2)) &&\n      !data.match(/(?<!\\\\)(\\\\\\\\)*\\\\/)\n    ) {\n      break\n    }\n    data += parser.template[parser.index++]\n  }\n\n  parser.index++\n  return char + data + char\n}\n\nconst ENDS_WITH_ESCAPE_REGEX = /(?<!\\\\)(\\\\\\\\)*\\\\$/\nconst RESERVED_DELIMITERS = ['{', '}', '--', '/*', '*/']\n\nexport function text(parser: Parser) {\n  const start = parser.index\n  let data = ''\n\n  while (parser.index < parser.template.length) {\n    const isEscaping = ENDS_WITH_ESCAPE_REGEX.test(data)\n    if (isEscaping) data = data.slice(0, -1) // Remove the escape character\n\n    if (\n      !isEscaping &&\n      RESERVED_DELIMITERS.some((sample) => parser.match(sample))\n    ) {\n      break\n    }\n    if (!isEscaping && parser.matchRegex(STRING_DELIMITERS_REGEX)) {\n      data += textInString(parser, parser.template[parser.index++]!)\n      continue\n    }\n    data += parser.template[parser.index++]\n  }\n\n  const node = {\n    start,\n    end: parser.index,\n    type: 'Text',\n    raw: data,\n    data: data.replace(/(?<!\\\\)\\\\{/g, '{').replace(/(?<!\\\\)\\\\}/g, '}'),\n  }\n\n  parser.current().children!.push(node)\n}\n","import { Parser } from '..'\nimport { dashComment } from './dash_comment'\nimport { multiLineComment } from './multi_line_comment'\nimport { mustache } from './mustache'\nimport { text } from './text'\n\nexport default function fragment(parser: Parser): (parser: Parser) => void {\n  if (parser.match('{') || parser.match('}')) {\n    return mustache\n  }\n  if (parser.match('/*') || parser.match('*/')) {\n    return multiLineComment\n  }\n  if (parser.match('--')) {\n    return dashComment\n  }\n\n  return text\n}\n","import type CompileError from '../error/error'\nimport { error } from '../error/error'\nimport { type Fragment, type TemplateNode } from './interfaces'\nimport PARSER_ERRORS from '../error/errors'\nimport fullCharCodeAt from './utils/full_char_code_at'\nimport { reserved } from '../utils/names'\n// @ts-expect-error - no types\nimport { isIdentifierStart, isIdentifierChar } from 'acorn'\nimport fragment from './state/fragment'\n\nexport default function parse(template: string) {\n  return new Parser(template).parse()\n}\n\ntype ParserState = (parser: Parser) => void | ParserState\n\nexport class Parser {\n  index: number = 0\n  stack: TemplateNode[] = []\n\n  constructor(public template: string) {}\n\n  parse(): Fragment {\n    const template: Fragment = {\n      start: 0,\n      end: this.template.length,\n      type: 'Fragment',\n      children: [],\n    }\n    this.stack.push(template)\n\n    let state: ParserState = fragment\n    while (this.index < this.template.length) {\n      state = state(this) || fragment\n    }\n    if (this.stack.length > 1) {\n      const current = this.current()\n      this.error(\n        {\n          code: `unclosed-block`,\n          message: `Block was left open`,\n        },\n        current.start!,\n      )\n    }\n    if (state !== fragment) {\n      this.error({\n        code: `unexpected-eof`,\n        message: `Unexpected end of input`,\n      })\n    }\n    if (template.children.length) {\n      let start = template.children[0]!.start!\n      while (/\\s/.test(template[start])) start += 1\n      let end = template.children[template.children.length - 1]!.end!\n      while (/\\s/.test(template[end - 1])) end -= 1\n      template.start = start\n      template.end = end\n    } else {\n      template.start = template.end = null\n    }\n\n    return template\n  }\n\n  current(): TemplateNode {\n    return this.stack[this.stack.length - 1]!\n  }\n\n  match(str: string) {\n    return this.template.slice(this.index, this.index + str.length) === str\n  }\n\n  allowWhitespace() {\n    while (\n      this.index < this.template.length &&\n      /\\s/.test(this.template[this.index] || '')\n    ) {\n      this.index++\n    }\n  }\n\n  requireWhitespace() {\n    if (!/\\s/.test(this.template[this.index]!)) {\n      this.error({\n        code: 'missing-whitespace',\n        message: 'Expected whitespace',\n      })\n    }\n    this.allowWhitespace()\n  }\n\n  eat(\n    str: string,\n    required: boolean = false,\n    error?: { code: string; message: string },\n  ) {\n    if (this.match(str)) {\n      this.index += str.length\n      return true\n    }\n    if (required) {\n      this.error(\n        error ||\n          (this.index === this.template.length\n            ? PARSER_ERRORS.unexpectedEofToken(str)\n            : PARSER_ERRORS.unexpectedToken(str)),\n      )\n    }\n    return false\n  }\n\n  error(\n    { code, message }: { code: string; message: string },\n    index = this.index,\n  ) {\n    error(message, {\n      name: 'ParseError',\n      code,\n      source: this.template,\n      start: index - 1,\n    })\n  }\n\n  acornError(err: CompileError) {\n    this.error(\n      {\n        code: 'parse-error',\n        message: err.message.replace(/ \\(\\d+:\\d+\\)$/, ''),\n      },\n      err.pos,\n    )\n  }\n\n  matchRegex(pattern: RegExp) {\n    const match = pattern.exec(this.template.slice(this.index))\n    if (!match || match.index !== 0) return null\n    return match[0]\n  }\n\n  read(pattern: RegExp) {\n    const result = this.matchRegex(pattern)\n    if (result) this.index += result.length\n    return result\n  }\n\n  readIdentifier(allowReserved: boolean = false) {\n    const start = this.index\n    let i = this.index\n    const code = fullCharCodeAt(this.template, i)\n    if (!isIdentifierStart(code, true)) return null\n    i += code <= 0xffff ? 1 : 2\n    while (i < this.template.length) {\n      const code = fullCharCodeAt(this.template, i)\n      if (!isIdentifierChar(code, true)) break\n      i += code <= 0xffff ? 1 : 2\n    }\n    const identifier = this.template.slice(this.index, (this.index = i))\n    if (!allowReserved && reserved.has(identifier)) {\n      this.error(\n        {\n          code: 'unexpected-reserved-word',\n          message: `'${identifier}' is a reserved word in JavaScript and cannot be used here`,\n        },\n        start,\n      )\n    }\n    return identifier\n  }\n}\n","export default class Scope {\n  /**\n   * Global stash\n   * All variable values are stored in a single global array. This is done to allow multiple\n   * scopes to share the same variable values and be able to modify them.\n   *\n   * For example:\n   * ```sql\n   * {var1 = 1}\n   * {#if <condition>}\n   *  {var1 = 2}\n   *  {var2 = 3}\n   * {/if}\n   * ```\n   * In this case, there are two scopes: root and if. Both scopes share the same variable `var1`,\n   * and modifying it in the if scope should also modify it in the root scope. But `var2` is only\n   * defined in the if scope and should not be accessible in the root scope.\n   */\n  private static stash: unknown[] = [] // Stash of every variable value in every scope\n  private static readFromStash(index: number): unknown {\n    return Scope.stash[index]\n  }\n  private static addToStash(value: unknown): number {\n    Scope.stash.push(value)\n    return Scope.stash.length - 1\n  }\n\n  private static modifyStash(index: number, value: unknown): void {\n    Scope.stash[index] = value\n  }\n\n  /**\n   * Local scope\n   * Every scope has its own local stash that contains the indexes of the variables and constants\n   * in the global stash.\n   */\n  private consts: Record<string, number> = {} // Index of every constant in the stash in the current scope\n  private vars: Record<string, number> = {} // Index of every variable in the stash in the current scope\n\n  constructor() {}\n\n  exists(name: string): boolean {\n    return name in this.consts || name in this.vars\n  }\n\n  isConst(name: string): boolean {\n    return name in this.consts\n  }\n\n  get(name: string): unknown {\n    const index = this.consts[name] ?? this.vars[name] ?? undefined\n    if (index === undefined)\n      throw new Error(`Variable '${name}' does not exist`)\n    return Scope.readFromStash(index)\n  }\n\n  defineConst(name: string, value: unknown): void {\n    if (this.exists(name)) throw new Error(`Variable '${name}' already exists`)\n    this.consts[name] = Scope.addToStash(value)\n  }\n\n  set(name: string, value: unknown): void {\n    if (this.isConst(name))\n      throw new Error(`Constant '${name}' cannot be modified`)\n    if (!this.exists(name)) {\n      this.vars[name] = Scope.addToStash(value)\n      return\n    }\n    const index = this.vars[name]!\n    Scope.modifyStash(index, value)\n  }\n\n  copy(): Scope {\n    const scope = new Scope()\n    scope.consts = { ...this.consts }\n    scope.vars = { ...this.vars }\n    return scope\n  }\n}\n","import { Node } from 'estree'\nimport Scope from '../scope'\nimport type { ResolveFn, SupportedMethod } from '../types'\n\nexport enum NodeType {\n  Literal = 'Literal',\n  Identifier = 'Identifier',\n  ObjectExpression = 'ObjectExpression',\n  ArrayExpression = 'ArrayExpression',\n  SequenceExpression = 'SequenceExpression',\n  LogicalExpression = 'LogicalExpression',\n  BinaryExpression = 'BinaryExpression',\n  UnaryExpression = 'UnaryExpression',\n  AssignmentExpression = 'AssignmentExpression',\n  UpdateExpression = 'UpdateExpression',\n  MemberExpression = 'MemberExpression',\n  ConditionalExpression = 'ConditionalExpression',\n  CallExpression = 'CallExpression',\n  ChainExpression = 'ChainExpression',\n}\n\nexport type ResolveNodeProps<N extends Node> = {\n  node: N\n  scope: Scope\n  raiseError: (\n    { code, message }: { code: string; message: string },\n    node: Node,\n  ) => never\n  supportedMethods: Record<string, SupportedMethod>\n  willInterpolate: boolean\n  resolveFn: ResolveFn\n}\n\nexport type ReadNodeMetadataProps<N extends Node> = {\n  node: N\n  supportedMethods: Record<string, SupportedMethod>\n}\n","import { QueryMetadata } from './types'\nimport { createHash } from 'node:crypto'\n\nexport function mergeMetadata(...metadata: QueryMetadata[]): QueryMetadata {\n  const config = metadata.reduce((acc, m) => ({ ...acc, ...m.config }), {})\n  const methods = metadata.reduce(\n    (acc, m) => new Set([...acc, ...m.methods]),\n    new Set<string>(),\n  )\n\n  const hashes = metadata.map((m) => m.sqlHash).filter(Boolean) as string[]\n  let sqlHash = undefined\n  if (hashes.length === 1) {\n    sqlHash = hashes[0]\n  } else if (hashes.length > 1) {\n    const hash = createHash('sha256')\n    for (const h of hashes) hash.update(h)\n    sqlHash = hash.digest('hex')\n  }\n\n  const rawSqls = metadata.map((m) => m.rawSql).filter(Boolean)\n  if (rawSqls.length > 1) {\n    throw new Error('Cannot merge metadata with multiple rawSqls')\n  }\n  const rawSql = rawSqls[0]\n\n  return {\n    config,\n    methods,\n    rawSql,\n    sqlHash,\n  }\n}\n\nexport function emptyMetadata(): QueryMetadata {\n  return {\n    config: {},\n    methods: new Set<string>(),\n    rawSql: undefined,\n    sqlHash: undefined,\n  }\n}\n","import { getLogicNodeMetadata, resolveLogicNode } from '..'\nimport { emptyMetadata, mergeMetadata } from '../../utils'\nimport type { ReadNodeMetadataProps, ResolveNodeProps } from '../types'\nimport type { ArrayExpression } from 'estree'\n\n/**\n * ### ArrayExpression\n * Returns an array of values\n */\n\nexport async function resolve({\n  node,\n  ...props\n}: ResolveNodeProps<ArrayExpression>) {\n  return await Promise.all(\n    node.elements.map((element) =>\n      element\n        ? resolveLogicNode({\n            node: element,\n            ...props,\n          })\n        : null,\n    ),\n  )\n}\n\nexport async function readMetadata({\n  node,\n  ...props\n}: ReadNodeMetadataProps<ArrayExpression>) {\n  const childrenMetadata = await Promise.all(\n    node.elements.map(async (element) => {\n      if (element)\n        return await getLogicNodeMetadata({ node: element, ...props })\n      return emptyMetadata()\n    }),\n  )\n  return mergeMetadata(...childrenMetadata)\n}\n","// https://github.com/estree/estree/blob/master/es5.md#binary-operations\nexport const BINARY_OPERATOR_METHODS: {\n  [operator: string]: (left: any, right: any) => unknown\n} = {\n  // BinaryExpression\n  '==': (left, right) => left == right,\n  '!=': (left, right) => left != right,\n  '===': (left, right) => left === right,\n  '!==': (left, right) => left !== right,\n  '<': (left, right) => left < right,\n  '<=': (left, right) => left <= right,\n  '>': (left, right) => left > right,\n  '>=': (left, right) => left >= right,\n  '<<': (left, right) => left << right,\n  '>>': (left, right) => left >> right,\n  '>>>': (left, right) => left >>> right,\n  '+': (left, right) => left + right,\n  '-': (left, right) => left - right,\n  '*': (left, right) => left * right,\n  '/': (left, right) => left / right,\n  '%': (left, right) => left % right,\n  '|': (left, right) => left | right,\n  '^': (left, right) => left ^ right,\n  '&': (left, right) => left & right,\n  in: (left, right) => left in right,\n  instanceof: (left, right) => (left as object) instanceof right,\n\n  // LogicalExpression\n  '||': (left, right) => left || right,\n  '&&': (left, right) => left && right,\n  '??': (left, right) => left ?? right,\n}\n\n// https://github.com/estree/estree/blob/master/es5.md#unary-operations\nexport const UNARY_OPERATOR_METHODS: {\n  [operator: string]: (value: any, prefix: any) => unknown\n} = {\n  // UnaryExpression\n  '-': (value, prefix) => (prefix ? -value : value),\n  '+': (value, prefix) => (prefix ? +value : value),\n  '!': (value, _) => !value,\n  '~': (value, _) => ~value,\n  typeof: (value, _) => typeof value,\n  void: (value, _) => void value,\n}\n\n// https://github.com/estree/estree/blob/master/es5.md#memberexpression\nexport const MEMBER_EXPRESSION_METHOD = (\n  object: any,\n  property: any,\n): unknown => {\n  const value = object[property]\n  return typeof value === 'function' ? value.bind(object) : value\n}\n\n// https://github.com/estree/estree/blob/master/es5.md#assignmentexpression\nexport const ASSIGNMENT_OPERATOR_METHODS: {\n  [operator: string]: (left: any, right: any) => unknown\n} = {\n  '=': (_, right) => right,\n  '+=': (left, right) => left + right,\n  '-=': (left, right) => left - right,\n  '*=': (left, right) => left * right,\n  '/=': (left, right) => left / right,\n  '%=': (left, right) => left % right,\n  '<<=': (left, right) => left << right,\n  '>>=': (left, right) => left >> right,\n  '>>>=': (left, right) => left >>> right,\n  '|=': (left, right) => left | right,\n  '^=': (left, right) => left ^ right,\n  '&=': (left, right) => left & right,\n}\n","import { getLogicNodeMetadata, resolveLogicNode } from '..'\nimport errors from '../../../error/errors'\nimport { mergeMetadata } from '../../utils'\nimport { ASSIGNMENT_OPERATOR_METHODS } from '../operators'\nimport type { ReadNodeMetadataProps, ResolveNodeProps } from '../types'\nimport type {\n  AssignmentExpression,\n  AssignmentOperator,\n  Identifier,\n  MemberExpression,\n} from 'estree'\n\n/**\n * ### AssignmentExpression\n * Represents an assignment or update to a variable or property. Returns the newly assigned value.\n * The assignment can be made to an existing variable or property, or to a new one. Assignments to constants are not allowed.\n *\n * Examples: `foo = 1` `obj.foo = 'bar'` `foo += 1`\n */\nexport async function resolve({\n  node,\n  scope,\n  raiseError,\n  ...props\n}: ResolveNodeProps<AssignmentExpression>) {\n  const assignmentOperator = node.operator\n  if (!(assignmentOperator in ASSIGNMENT_OPERATOR_METHODS)) {\n    raiseError(errors.unsupportedOperator(assignmentOperator), node)\n  }\n  const assignmentMethod = ASSIGNMENT_OPERATOR_METHODS[assignmentOperator]!\n\n  const assignmentValue = await resolveLogicNode({\n    node: node.right,\n    scope,\n    raiseError,\n    ...props,\n  })\n\n  if (node.left.type === 'Identifier') {\n    return await assignToVariable({\n      assignmentOperator,\n      assignmentMethod,\n      assignmentValue,\n      node: node.left,\n      scope,\n      raiseError,\n      ...props,\n    })\n  }\n\n  if (node.left.type === 'MemberExpression') {\n    return await assignToProperty({\n      assignmentOperator,\n      assignmentMethod,\n      assignmentValue,\n      node: node.left,\n      scope,\n      raiseError,\n      ...props,\n    })\n  }\n\n  raiseError(errors.invalidAssignment, node)\n}\n\nasync function assignToVariable({\n  assignmentOperator,\n  assignmentMethod,\n  assignmentValue,\n  node,\n  scope,\n  raiseError,\n}: ResolveNodeProps<Identifier> & {\n  assignmentOperator: AssignmentOperator\n  assignmentMethod: (typeof ASSIGNMENT_OPERATOR_METHODS)[keyof typeof ASSIGNMENT_OPERATOR_METHODS]\n  assignmentValue: unknown\n}) {\n  const assignedVariableName = node.name\n  if (scope.isConst(assignedVariableName)) {\n    raiseError(errors.constantReassignment, node)\n  }\n\n  if (assignmentOperator != '=' && !scope.exists(assignedVariableName)) {\n    raiseError(errors.variableNotDeclared(assignedVariableName), node)\n  }\n\n  const updatedValue = assignmentMethod(\n    scope.exists(assignedVariableName)\n      ? scope.get(assignedVariableName)\n      : undefined,\n    assignmentValue,\n  )\n\n  scope.set(assignedVariableName, updatedValue)\n  return updatedValue\n}\n\nasync function assignToProperty({\n  assignmentOperator,\n  assignmentMethod,\n  assignmentValue,\n  node,\n  ...props\n}: ResolveNodeProps<MemberExpression> & {\n  assignmentOperator: AssignmentOperator\n  assignmentMethod: (typeof ASSIGNMENT_OPERATOR_METHODS)[keyof typeof ASSIGNMENT_OPERATOR_METHODS]\n  assignmentValue: unknown\n}) {\n  const { raiseError } = props\n  const object = (await resolveLogicNode({\n    node: node.object,\n    ...props,\n  })) as { [key: string]: any }\n\n  const property = (\n    node.computed\n      ? await resolveLogicNode({\n          node: node.property,\n          ...props,\n        })\n      : (node.property as Identifier).name\n  ) as string\n\n  if (assignmentOperator != '=' && !(property in object)) {\n    raiseError(errors.propertyNotExists(property), node)\n  }\n\n  const originalValue = object[property]\n  const updatedValue = assignmentMethod(originalValue, assignmentValue)\n  object[property] = updatedValue\n  return updatedValue\n}\n\nexport async function readMetadata({\n  node,\n  ...props\n}: ReadNodeMetadataProps<AssignmentExpression>) {\n  return mergeMetadata(\n    await getLogicNodeMetadata({ node: node.right, ...props }),\n    await getLogicNodeMetadata({ node: node.left, ...props }),\n  )\n}\n","import { getLogicNodeMetadata, resolveLogicNode } from '..'\nimport type { ReadNodeMetadataProps, ResolveNodeProps } from '../types'\nimport type { ChainExpression } from 'estree'\n\n/**\n * ### Chain Expression\n * Represents a chain of operations. This is only being used for optional member expressions '?.'\n */\nexport async function resolve({\n  node,\n  ...props\n}: ResolveNodeProps<ChainExpression>) {\n  return resolveLogicNode({\n    node: node.expression,\n    ...props,\n  })\n}\n\nexport async function readMetadata({\n  node,\n  ...props\n}: ReadNodeMetadataProps<ChainExpression>) {\n  return await getLogicNodeMetadata({\n    node: node.expression,\n    ...props,\n  })\n}\n","import { getLogicNodeMetadata, resolveLogicNode } from '..'\nimport CompileError from '../../../error/error'\nimport errors from '../../../error/errors'\nimport { emptyMetadata, mergeMetadata } from '../../utils'\nimport type { ReadNodeMetadataProps, ResolveNodeProps } from '../types'\nimport { NodeType } from '../types'\nimport type { Identifier, Literal, SimpleCallExpression } from 'estree'\n\n/**\n * ### CallExpression\n * Represents a method call.\n *\n * Examples: `foo()` `foo.bar()`\n */\nexport async function resolve(props: ResolveNodeProps<SimpleCallExpression>) {\n  const { node, supportedMethods, raiseError } = props\n  if (\n    node.callee.type === NodeType.Identifier &&\n    node.callee.name in supportedMethods\n  ) {\n    return resolveSupportedMethod(props)\n  }\n\n  const method = (await resolveLogicNode({\n    ...props,\n    node: node.callee,\n  })) as Function\n\n  if (typeof method !== 'function') {\n    raiseError(errors.notAFunction(typeof method), node)\n  }\n\n  const args = await resolveArgs(props)\n  return await runMethod({ ...props, method, args })\n}\n\nasync function resolveSupportedMethod(\n  props: ResolveNodeProps<SimpleCallExpression>,\n) {\n  const { node, supportedMethods, raiseError, willInterpolate, resolveFn } =\n    props\n  const methodName = (node.callee as Identifier).name\n  const { requirements: reqs, resolve: method } = supportedMethods[methodName]!\n  const requirements = {\n    interpolationPolicy: 'allow',\n    interpolationMethod: 'parameterize',\n    requireStaticArguments: false,\n    ...(reqs ?? {}),\n  }\n\n  if (requirements.requireStaticArguments && !onlyContainsStaticArgs(node)) {\n    raiseError(errors.functionRequiresStaticArguments(methodName), node)\n  }\n\n  if (requirements.interpolationPolicy === 'require' && !willInterpolate) {\n    raiseError(errors.functionRequiresInterpolation(methodName), node)\n  }\n\n  if (requirements.interpolationPolicy === 'disallow' && willInterpolate) {\n    raiseError(errors.functionDisallowsInterpolation(methodName), node)\n  }\n\n  const args = await resolveArgs(props)\n  const result = await runMethod({ ...props, method, args })\n\n  if (!willInterpolate) return result\n\n  if (requirements?.interpolationMethod === 'raw') {\n    return String(result)\n  }\n\n  return resolveFn(result)\n}\n\nfunction resolveArgs(\n  props: ResolveNodeProps<SimpleCallExpression>,\n): Promise<unknown[]> {\n  const { node } = props\n  return Promise.all(\n    node.arguments.map((arg) =>\n      resolveLogicNode({\n        ...props,\n        node: arg,\n        willInterpolate: false,\n      }),\n    ),\n  )\n}\n\ninterface SimpleCallExpressionWithStaticArgs extends SimpleCallExpression {\n  arguments: Literal[]\n}\nfunction onlyContainsStaticArgs(\n  node: SimpleCallExpression,\n): node is SimpleCallExpressionWithStaticArgs {\n  return node.arguments.every((arg) => arg.type === NodeType.Literal)\n}\n\nasync function runMethod({\n  method,\n  args,\n  node,\n  willInterpolate,\n  raiseError,\n}: ResolveNodeProps<SimpleCallExpression> & {\n  method: Function\n  args: unknown[]\n}) {\n  try {\n    const result = await method(...args)\n    if (willInterpolate) {\n      return String(result)\n    }\n    return result\n  } catch (error: unknown) {\n    if (error instanceof CompileError) throw error\n    raiseError(errors.functionCallError(error), node)\n  }\n}\n\nexport async function readMetadata(\n  props: ReadNodeMetadataProps<SimpleCallExpression>,\n) {\n  const { node, supportedMethods } = props\n  const argumentsMetadata = await Promise.all(\n    node.arguments.map((arg) =>\n      getLogicNodeMetadata({\n        ...props,\n        node: arg,\n      }),\n    ),\n  )\n\n  const calleeMetadata = await getLogicNodeMetadata({\n    ...props,\n    node: node.callee,\n  })\n\n  let resultsMetadata = emptyMetadata()\n\n  if (node.callee.type === NodeType.Identifier) {\n    const methodName = node.callee.name\n    if (methodName in supportedMethods) {\n      calleeMetadata.methods.add(methodName)\n      const args = onlyContainsStaticArgs(node)\n        ? node.arguments.map((arg) => arg.value)\n        : []\n      resultsMetadata = await supportedMethods[methodName]!.readMetadata(args)\n    }\n  }\n\n  return mergeMetadata(calleeMetadata, resultsMetadata, ...argumentsMetadata)\n}\n","import { getLogicNodeMetadata, resolveLogicNode } from '..'\nimport errors from '../../../error/errors'\nimport { mergeMetadata } from '../../utils'\nimport { BINARY_OPERATOR_METHODS } from '../operators'\nimport type { ReadNodeMetadataProps, ResolveNodeProps } from '../types'\nimport type { BinaryExpression, LogicalExpression } from 'estree'\n\n/**\n * ### BinaryExpression\n * Represents a simple operation between two operands.\n *\n * Example: `{a > b}`\n */\nexport async function resolve({\n  node,\n  raiseError,\n  ...props\n}: ResolveNodeProps<BinaryExpression | LogicalExpression>) {\n  const binaryOperator = node.operator\n  if (!(binaryOperator in BINARY_OPERATOR_METHODS)) {\n    raiseError(errors.unsupportedOperator(binaryOperator), node)\n  }\n  const leftOperand = await resolveLogicNode({\n    node: node.left,\n    raiseError,\n    ...props,\n  })\n  const rightOperand = await resolveLogicNode({\n    node: node.right,\n    raiseError,\n    ...props,\n  })\n\n  return BINARY_OPERATOR_METHODS[binaryOperator]?.(leftOperand, rightOperand)\n}\n\nexport async function readMetadata({\n  node,\n  ...props\n}: ReadNodeMetadataProps<BinaryExpression | LogicalExpression>) {\n  return mergeMetadata(\n    await getLogicNodeMetadata({\n      node: node.left,\n      ...props,\n    }),\n    await getLogicNodeMetadata({\n      node: node.right,\n      ...props,\n    }),\n  )\n}\n","import { getLogicNodeMetadata, resolveLogicNode } from '..'\nimport { mergeMetadata } from '../../utils'\nimport type { ReadNodeMetadataProps, ResolveNodeProps } from '../types'\nimport type { ConditionalExpression } from 'estree'\n\n/**\n * ### ConditionalExpression\n * Represents a ternary operation.\n *\n * Example: `a ? b : c`\n */\nexport async function resolve({\n  node,\n  ...props\n}: ResolveNodeProps<ConditionalExpression>) {\n  const condition = await resolveLogicNode({ node: node.test, ...props })\n  return await resolveLogicNode({\n    node: condition ? node.consequent : node.alternate,\n    ...props,\n  })\n}\n\nexport async function readMetadata({\n  node,\n  ...props\n}: ReadNodeMetadataProps<ConditionalExpression>) {\n  return mergeMetadata(\n    await getLogicNodeMetadata({\n      node: node.test,\n      ...props,\n    }),\n    await getLogicNodeMetadata({\n      node: node.consequent,\n      ...props,\n    }),\n    await getLogicNodeMetadata({\n      node: node.alternate,\n      ...props,\n    }),\n  )\n}\n","import errors from '../../../error/errors'\nimport type { ResolveNodeProps } from '../types'\nimport type { Identifier } from 'estree'\n\n/**\n * ### Identifier\n * Represents a variable from the scope.\n */\nexport async function resolve({\n  node,\n  scope,\n  raiseError,\n}: ResolveNodeProps<Identifier>) {\n  if (!scope.exists(node.name)) {\n    raiseError(errors.variableNotDeclared(node.name), node)\n  }\n  return scope.get(node.name)\n}\n","import { type ResolveNodeProps } from '../types'\nimport { type Literal } from 'estree'\n\n/**\n * ### Literal\n * Represents a literal value.\n */\nexport async function resolve({ node }: ResolveNodeProps<Literal>) {\n  return node.value\n}\n","import { getLogicNodeMetadata, resolveLogicNode } from '..'\nimport errors from '../../../error/errors'\nimport { mergeMetadata } from '../../utils'\nimport { ReadNodeMetadataProps, type ResolveNodeProps } from '../types'\nimport {\n  Property,\n  SpreadElement,\n  type Identifier,\n  type ObjectExpression,\n} from 'estree'\n\n/**\n * ### ObjectExpression\n * Represents a javascript Object\n */\nexport async function resolve({\n  node,\n  scope,\n  raiseError,\n  ...props\n}: ResolveNodeProps<ObjectExpression>) {\n  const resolvedObject: { [key: string]: any } = {}\n  for (const prop of node.properties) {\n    if (prop.type !== 'Property') {\n      throw raiseError(errors.invalidObjectKey, node)\n    }\n    const key = prop.key as Identifier\n    const value = await resolveLogicNode({\n      node: prop.value,\n      scope,\n      raiseError,\n      ...props,\n    })\n    resolvedObject[key.name] = value\n  }\n  return resolvedObject\n}\n\nfunction isProperty(prop: Property | SpreadElement): prop is Property {\n  return prop.type === 'Property'\n}\n\nexport async function readMetadata({\n  node,\n  ...props\n}: ReadNodeMetadataProps<ObjectExpression>) {\n  const propertiesMetadata = await Promise.all(\n    node.properties.filter(isProperty).map((prop) =>\n      Promise.all([\n        getLogicNodeMetadata({\n          node: prop.key,\n          ...props,\n        }),\n        getLogicNodeMetadata({\n          node: prop.value,\n          ...props,\n        }),\n      ]),\n    ),\n  )\n\n  return mergeMetadata(...propertiesMetadata.flat())\n}\n","import { getLogicNodeMetadata, resolveLogicNode } from '..'\nimport { emptyMetadata, mergeMetadata } from '../../utils'\nimport { MEMBER_EXPRESSION_METHOD } from '../operators'\nimport type { ReadNodeMetadataProps, ResolveNodeProps } from '../types'\nimport type { MemberExpression, Identifier } from 'estree'\n\n/**\n * ### MemberExpression\n * Represents a property from an object. If the property does not exist in the object, it will return undefined.\n */\nexport async function resolve({\n  node,\n  ...props\n}: ResolveNodeProps<MemberExpression>) {\n  const object = await resolveLogicNode({\n    node: node.object,\n    ...props,\n  })\n\n  // Accessing to the property can be optional (?.)\n  if (object == null && node.optional) return undefined\n\n  const property = node.computed\n    ? await resolveLogicNode({\n        node: node.property,\n        ...props,\n      })\n    : (node.property as Identifier).name\n\n  return MEMBER_EXPRESSION_METHOD(object, property)\n}\n\nexport async function readMetadata({\n  node,\n  ...props\n}: ReadNodeMetadataProps<MemberExpression>) {\n  return mergeMetadata(\n    await getLogicNodeMetadata({\n      node: node.object,\n      ...props,\n    }),\n    node.computed\n      ? await getLogicNodeMetadata({ node: node.property, ...props })\n      : emptyMetadata(),\n  )\n}\n","import { getLogicNodeMetadata, resolveLogicNode } from '..'\nimport { mergeMetadata } from '../../utils'\nimport type { ReadNodeMetadataProps, ResolveNodeProps } from '../types'\nimport type { SequenceExpression } from 'estree'\n\n/**\n * ### SequenceExpression\n * Represents a sequence of expressions. It is only used to evaluate ?. operators.\n */\nexport async function resolve({\n  node,\n  ...props\n}: ResolveNodeProps<SequenceExpression>) {\n  return await Promise.all(\n    node.expressions.map((expression) =>\n      resolveLogicNode({ node: expression, ...props }),\n    ),\n  )\n}\n\nexport async function readMetadata({\n  node,\n  ...props\n}: ReadNodeMetadataProps<SequenceExpression>) {\n  const childrenMetadata = await Promise.all(\n    node.expressions.map(async (expression) =>\n      getLogicNodeMetadata({ node: expression, ...props }),\n    ),\n  )\n  return mergeMetadata(...childrenMetadata)\n}\n","import { getLogicNodeMetadata, resolveLogicNode } from '..'\nimport errors from '../../../error/errors'\nimport { UNARY_OPERATOR_METHODS } from '../operators'\nimport type { ReadNodeMetadataProps, ResolveNodeProps } from '../types'\nimport type { UnaryExpression } from 'estree'\n\n/**\n * ### UnaryExpression\n * Represents a simple operation on a single operand, either as a prefix or suffix.\n *\n * Example: `{!a}`\n */\nexport async function resolve({\n  node,\n  raiseError,\n  ...props\n}: ResolveNodeProps<UnaryExpression>) {\n  const unaryOperator = node.operator\n  if (!(unaryOperator in UNARY_OPERATOR_METHODS)) {\n    raiseError(errors.unsupportedOperator(unaryOperator), node)\n  }\n\n  const unaryArgument = await resolveLogicNode({\n    node: node.argument,\n    raiseError,\n    ...props,\n  })\n  const unaryPrefix = node.prefix\n  return UNARY_OPERATOR_METHODS[unaryOperator]?.(unaryArgument, unaryPrefix)\n}\n\nexport async function readMetadata({\n  node,\n  ...props\n}: ReadNodeMetadataProps<UnaryExpression>) {\n  return await getLogicNodeMetadata({\n    node: node.argument,\n    ...props,\n  })\n}\n","import { getLogicNodeMetadata, resolveLogicNode } from '..'\nimport errors from '../../../error/errors'\nimport type { ReadNodeMetadataProps, ResolveNodeProps } from '../types'\nimport type { AssignmentExpression, UpdateExpression } from 'estree'\n\n/**\n * ### UpdateExpression\n * Represents a javascript update expression.\n * Depending on the operator, it can increment or decrement a value.\n * Depending on the position of the operator, the return value can be resolved before or after the operation.\n *\n * Examples: `{--foo}` `{bar++}`\n */\nexport async function resolve({\n  node,\n  scope,\n  raiseError,\n  ...props\n}: ResolveNodeProps<UpdateExpression>) {\n  const updateOperator = node.operator\n\n  if (!['++', '--'].includes(updateOperator)) {\n    raiseError(errors.unsupportedOperator(updateOperator), node)\n  }\n\n  const assignmentOperators = {\n    '++': '+=',\n    '--': '-=',\n  }\n\n  const originalValue = await resolveLogicNode({\n    node: node.argument,\n    scope,\n    raiseError,\n    ...props,\n  })\n\n  if (typeof originalValue !== 'number') {\n    raiseError(errors.invalidUpdate(updateOperator, typeof originalValue), node)\n  }\n\n  // Simulate an AssignmentExpression with the same operation\n  const assignmentNode = {\n    ...node,\n    type: 'AssignmentExpression',\n    left: node.argument,\n    operator: assignmentOperators[updateOperator],\n    right: {\n      type: 'Literal',\n      value: 1,\n    },\n  } as AssignmentExpression\n\n  // Perform the assignment\n  const updatedValue = await resolveLogicNode({\n    node: assignmentNode,\n    scope,\n    raiseError,\n    ...props,\n  })\n\n  return node.prefix ? updatedValue : originalValue\n}\n\nexport async function readMetadata({\n  node,\n  ...props\n}: ReadNodeMetadataProps<UpdateExpression>) {\n  return await getLogicNodeMetadata({\n    node: node.argument,\n    ...props,\n  })\n}\n","import {\n  resolve as resolveArrayExpression,\n  readMetadata as readArrayMetadata,\n} from './arrayExpression'\nimport {\n  resolve as resolveAssignmentExpression,\n  readMetadata as readAssignmentMetadata,\n} from './assignmentExpression'\nimport {\n  resolve as resolveChainExpression,\n  readMetadata as readChainMetadata,\n} from './chainExpression'\nimport {\n  resolve as resolveCallExpression,\n  readMetadata as readCallMetadata,\n} from './callExpression'\nimport {\n  resolve as resolveBinaryExpression,\n  readMetadata as readBinaryMetadata,\n} from './binaryExpression'\nimport {\n  resolve as resolveConditionalExpression,\n  readMetadata as readConditionalMetadata,\n} from './conditionalExpression'\nimport { resolve as resolveIdentifier } from './identifier'\nimport { resolve as resolveLiteral } from './literal'\nimport {\n  resolve as resolveObjectExpression,\n  readMetadata as readObjectMetadata,\n} from './objectExpression'\nimport {\n  resolve as resolveMemberExpression,\n  readMetadata as readMemberMetadata,\n} from './memberExpression'\nimport {\n  resolve as resolveSequenceExpression,\n  readMetadata as readSequenceMetadata,\n} from './sequenceExpression'\nimport {\n  resolve as resolveUnaryExpression,\n  readMetadata as readUnaryMetadata,\n} from './unaryExpression'\nimport {\n  resolve as resolveUpdateExpression,\n  readMetadata as readUpdateMetadata,\n} from './updateExpression'\nimport { ReadNodeMetadataProps, NodeType, ResolveNodeProps } from '../types'\nimport { Node } from 'estree'\nimport { QueryMetadata } from '../../types'\nimport { emptyMetadata } from '../../utils'\n\ntype ResolveNodeFn = (props: ResolveNodeProps<Node>) => Promise<unknown>\ntype ReadNodeMetadataFn = (\n  props: ReadNodeMetadataProps<Node>,\n) => Promise<QueryMetadata>\n\nexport const nodeResolvers: Record<NodeType, ResolveNodeFn> = {\n  [NodeType.ArrayExpression]: resolveArrayExpression as ResolveNodeFn,\n  [NodeType.AssignmentExpression]: resolveAssignmentExpression as ResolveNodeFn,\n  [NodeType.BinaryExpression]: resolveBinaryExpression as ResolveNodeFn,\n  [NodeType.CallExpression]: resolveCallExpression as ResolveNodeFn,\n  [NodeType.ChainExpression]: resolveChainExpression as ResolveNodeFn,\n  [NodeType.ConditionalExpression]:\n    resolveConditionalExpression as ResolveNodeFn,\n  [NodeType.Identifier]: resolveIdentifier as ResolveNodeFn,\n  [NodeType.Literal]: resolveLiteral as ResolveNodeFn,\n  [NodeType.LogicalExpression]: resolveBinaryExpression as ResolveNodeFn,\n  [NodeType.ObjectExpression]: resolveObjectExpression as ResolveNodeFn,\n  [NodeType.MemberExpression]: resolveMemberExpression as ResolveNodeFn,\n  [NodeType.SequenceExpression]: resolveSequenceExpression as ResolveNodeFn,\n  [NodeType.UnaryExpression]: resolveUnaryExpression as ResolveNodeFn,\n  [NodeType.UpdateExpression]: resolveUpdateExpression as ResolveNodeFn,\n}\n\nexport const nodeMetadataReader: Record<NodeType, ReadNodeMetadataFn> = {\n  [NodeType.Identifier]: async () => emptyMetadata(), // No metadata to read\n  [NodeType.Literal]: async () => emptyMetadata(), // No metadata to read\n\n  [NodeType.ArrayExpression]: readArrayMetadata as ReadNodeMetadataFn,\n  [NodeType.AssignmentExpression]: readAssignmentMetadata as ReadNodeMetadataFn,\n  [NodeType.BinaryExpression]: readBinaryMetadata as ReadNodeMetadataFn,\n  [NodeType.CallExpression]: readCallMetadata as ReadNodeMetadataFn,\n  [NodeType.ChainExpression]: readChainMetadata as ReadNodeMetadataFn,\n  [NodeType.ConditionalExpression]:\n    readConditionalMetadata as ReadNodeMetadataFn,\n  [NodeType.LogicalExpression]: readBinaryMetadata as ReadNodeMetadataFn,\n  [NodeType.ObjectExpression]: readObjectMetadata as ReadNodeMetadataFn,\n  [NodeType.MemberExpression]: readMemberMetadata as ReadNodeMetadataFn,\n  [NodeType.SequenceExpression]: readSequenceMetadata as ReadNodeMetadataFn,\n  [NodeType.UnaryExpression]: readUnaryMetadata as ReadNodeMetadataFn,\n  [NodeType.UpdateExpression]: readUpdateMetadata as ReadNodeMetadataFn,\n}\n","import { QueryMetadata } from '../types'\nimport { nodeResolvers, nodeMetadataReader } from './nodes'\nimport type { ReadNodeMetadataProps, NodeType, ResolveNodeProps } from './types'\nimport type { Node } from 'estree'\n\n/**\n * Given a node, calculates the resulting value.\n */\nexport async function resolveLogicNode(props: ResolveNodeProps<Node>) {\n  const type = props.node.type as NodeType\n  if (!nodeResolvers[type]) {\n    throw new Error(`Unknown node type: ${type}`)\n  }\n\n  const nodeResolver = nodeResolvers[props.node.type as NodeType]\n  return nodeResolver(props)\n}\n\n/**\n * Given a node, extracts the supported methods that are being invoked.\n */\nexport async function getLogicNodeMetadata(\n  props: ReadNodeMetadataProps<Node>,\n): Promise<QueryMetadata> {\n  const type = props.node.type as NodeType\n  if (!nodeMetadataReader[type]) {\n    throw new Error(`Unknown node type: ${type}`)\n  }\n\n  const methodExtractor = nodeMetadataReader[props.node.type as NodeType]\n  return methodExtractor(props)\n}\n","import { BaseNode, type TemplateNode } from '../parser/interfaces'\nimport type { Node, Identifier, Literal } from 'estree'\nimport parse from '../parser/index'\nimport { error } from '../error/error'\nimport errors from '../error/errors'\nimport Scope from './scope'\nimport { NodeType } from './logic/types'\nimport type { CompileContext, QueryMetadata } from './types'\nimport { getLogicNodeMetadata, resolveLogicNode } from './logic'\nimport { emptyMetadata, mergeMetadata } from './utils'\nimport { createHash } from 'node:crypto'\n\nexport class Compiler {\n  private context: CompileContext\n  private currentConfig: Record<string, unknown> = {}\n\n  constructor({ sql, supportedMethods = {}, resolveFn }: CompileContext) {\n    this.context = { sql, supportedMethods, resolveFn }\n  }\n\n  /**\n   * Resolves every block, expression, and function inside the SQL and returns the final query.\n   *\n   * Note: Compiling a query may take time in some cases, as some queries may contain expensive\n   * functions that need to be resolved at runtime.\n   */\n  async compileSQL(): Promise<string> {\n    const fragment = parse(this.context.sql)\n    const localScope = new Scope()\n    const compiledSql = (await this.resolveBaseNode(fragment, localScope, 0))\n      .replace(/ +/g, ' ') // Remove extra spaces\n      .trim() // Remove leading and trailing spaces\n\n    return compiledSql\n  }\n\n  /**\n   * Without compiling the SQL or resolving any expression, quickly reads the config and calls\n   * to the supported methods present in the SQL.\n   */\n  async readMetadata(): Promise<QueryMetadata> {\n    const fragment = parse(this.context.sql)\n    const rawSql = this.context.sql\n    const sqlHash = createHash('sha256').update(rawSql).digest('hex')\n    const baseMetadata = await this.getBaseNodeMetadata({\n      baseNode: fragment,\n      depth: 0,\n    })\n    return mergeMetadata(baseMetadata, { ...emptyMetadata(), sqlHash, rawSql })\n  }\n\n  /**\n   * Given a base node, returns the string that will replace it in the final SQL\n   */\n  private resolveBaseNode = async (\n    baseNode: BaseNode,\n    localScope: Scope,\n    depth: number,\n  ): Promise<string> => {\n    if (!baseNode) return ''\n\n    if (baseNode.type === 'Fragment') {\n      // Parent node, only one of its kind\n      return this.resolveBaseNodeChildren(baseNode.children, localScope, depth)\n    }\n\n    if (baseNode.type === 'Comment') {\n      return baseNode.raw\n    }\n\n    if (baseNode.type === 'Text') {\n      return baseNode.raw\n    }\n\n    if (baseNode.type === 'MustacheTag') {\n      const expression = baseNode.expression\n\n      // Some node expressions do not inject any value into the SQL\n      const silentExpressions = [NodeType.AssignmentExpression]\n\n      if (silentExpressions.includes(expression.type as NodeType)) {\n        await resolveLogicNode({\n          node: expression,\n          scope: localScope,\n          raiseError: this.expressionError.bind(this),\n          supportedMethods: this.context.supportedMethods,\n          willInterpolate: false,\n          resolveFn: this.context.resolveFn,\n        })\n        return ''\n      }\n\n      if (\n        // If the expression is a call to a supported method, the result WILL BE INTERPOLATED\n        expression.type === NodeType.CallExpression &&\n        expression.callee.type === NodeType.Identifier &&\n        expression.callee.name in this.context.supportedMethods\n      ) {\n        return (await resolveLogicNode({\n          node: expression,\n          scope: localScope,\n          raiseError: this.expressionError.bind(this),\n          supportedMethods: this.context.supportedMethods,\n          willInterpolate: true,\n          resolveFn: this.context.resolveFn,\n        })) as string\n      }\n\n      const value = await resolveLogicNode({\n        node: expression,\n        scope: localScope,\n        raiseError: this.expressionError.bind(this),\n        supportedMethods: this.context.supportedMethods,\n        willInterpolate: false,\n        resolveFn: this.context.resolveFn,\n      })\n      const resolvedValue = await this.context.resolveFn(value)\n\n      return resolvedValue\n    }\n\n    if (baseNode.type === 'ConstTag') {\n      // Only allow equal expressions to define constants\n      const expression = baseNode.expression\n      if (\n        expression.type !== 'AssignmentExpression' ||\n        expression.operator !== '=' ||\n        expression.left.type !== 'Identifier'\n      ) {\n        this.baseNodeError(errors.invalidConstantDefinition, baseNode)\n      }\n\n      const constName = (expression.left as Identifier).name\n      const constValue = await resolveLogicNode({\n        node: expression.right,\n        scope: localScope,\n        raiseError: this.expressionError.bind(this),\n        supportedMethods: this.context.supportedMethods,\n        willInterpolate: false,\n        resolveFn: this.context.resolveFn,\n      })\n      if (localScope.exists(constName)) {\n        this.baseNodeError(errors.variableAlreadyDeclared(constName), baseNode)\n      }\n      localScope.defineConst(constName, constValue)\n      return ''\n    }\n\n    if (baseNode.type === 'ConfigTag') {\n      if (depth > 0) {\n        this.baseNodeError(errors.configInsideBlock, baseNode)\n      }\n\n      const expression = baseNode.expression\n      if (\n        expression.type !== 'AssignmentExpression' ||\n        expression.operator !== '=' ||\n        expression.left.type !== 'Identifier'\n      ) {\n        this.baseNodeError(errors.invalidConfigDefinition, baseNode)\n      }\n\n      if (expression.right.type !== 'Literal') {\n        this.baseNodeError(errors.invalidConfigValue, baseNode)\n      }\n\n      return ''\n    }\n\n    if (baseNode.type === 'IfBlock') {\n      const condition = await resolveLogicNode({\n        node: baseNode.expression,\n        scope: localScope,\n        raiseError: this.expressionError.bind(this),\n        supportedMethods: this.context.supportedMethods,\n        willInterpolate: false,\n        resolveFn: this.context.resolveFn,\n      })\n      return condition\n        ? this.resolveBaseNodeChildren(baseNode.children, localScope, depth + 1)\n        : await this.resolveBaseNode(baseNode.else, localScope, depth + 1)\n    }\n\n    if (baseNode.type === 'ElseBlock') {\n      return this.resolveBaseNodeChildren(\n        baseNode.children,\n        localScope,\n        depth + 1,\n      )\n    }\n\n    if (baseNode.type === 'EachBlock') {\n      const iterableElement = await resolveLogicNode({\n        node: baseNode.expression,\n        scope: localScope,\n        raiseError: this.expressionError.bind(this),\n        supportedMethods: this.context.supportedMethods,\n        willInterpolate: false,\n        resolveFn: this.context.resolveFn,\n      })\n      if (!Array.isArray(iterableElement) || !iterableElement.length) {\n        return await this.resolveBaseNode(baseNode.else, localScope, depth + 1)\n      }\n\n      const contextVar = baseNode.context.name\n      const indexVar = baseNode.index\n      if (localScope.exists(contextVar)) {\n        this.baseNodeError(errors.variableAlreadyDeclared(contextVar), baseNode)\n      }\n      if (indexVar && localScope.exists(indexVar)) {\n        this.baseNodeError(errors.variableAlreadyDeclared(indexVar), baseNode)\n      }\n\n      const parsedChildren: string[] = []\n      for (let i = 0; i < iterableElement.length; i++) {\n        const element = iterableElement[i]\n        if (indexVar) localScope.set(indexVar, i)\n        localScope.set(contextVar, element)\n        parsedChildren.push(\n          await this.resolveBaseNodeChildren(\n            baseNode.children,\n            localScope,\n            depth + 1,\n          ),\n        )\n      }\n      return parsedChildren.join('') || ''\n    }\n\n    throw this.baseNodeError(\n      errors.unsupportedBaseNodeType(baseNode.type),\n      baseNode,\n    )\n  }\n\n  private resolveBaseNodeChildren = async (\n    children: TemplateNode[] | undefined,\n    localScope: Scope,\n    depth: number,\n  ): Promise<string> => {\n    const parsedChildren: string[] = []\n    const childrenScope = localScope.copy() // All children share the same scope\n    for (const child of children || []) {\n      const parsedChild = await this.resolveBaseNode(\n        child,\n        childrenScope,\n        depth,\n      )\n      parsedChildren.push(parsedChild)\n    }\n    return parsedChildren.join('') || ''\n  }\n\n  /**\n   * Given a base node, returns the list of defined configs and present methods from the supportedMethods.\n   */\n  private getBaseNodeMetadata = async ({\n    baseNode,\n    depth,\n  }: {\n    baseNode: BaseNode\n    depth: number\n  }): Promise<QueryMetadata> => {\n    if (!baseNode) return emptyMetadata()\n\n    if (baseNode.type === 'Fragment') {\n      const childrenMetadata = await Promise.all(\n        (baseNode.children || []).map((child) =>\n          this.getBaseNodeMetadata({\n            baseNode: child,\n            depth,\n          }),\n        ),\n      )\n      return mergeMetadata(...childrenMetadata)\n    }\n\n    // Not computed nodes. Do not contain any configs or methods\n    if (['Comment', 'Text'].includes(baseNode.type)) {\n      return emptyMetadata()\n    }\n\n    if (baseNode.type === 'MustacheTag') {\n      const expression = baseNode.expression\n\n      return await getLogicNodeMetadata({\n        node: expression,\n        supportedMethods: this.context.supportedMethods,\n      })\n    }\n\n    if (baseNode.type === 'ConstTag') {\n      // Only allow equal expressions to define constants\n      const expression = baseNode.expression\n\n      return await getLogicNodeMetadata({\n        node: expression,\n        supportedMethods: this.context.supportedMethods,\n      })\n    }\n\n    if (baseNode.type === 'ConfigTag') {\n      if (depth > 0) {\n        this.baseNodeError(errors.configInsideBlock, baseNode)\n      }\n\n      const expression = baseNode.expression\n      if (\n        expression.type !== 'AssignmentExpression' ||\n        expression.operator !== '=' ||\n        expression.left.type !== 'Identifier'\n      ) {\n        this.baseNodeError(errors.invalidConfigDefinition, baseNode)\n      }\n\n      if (expression.right.type !== 'Literal') {\n        this.baseNodeError(errors.invalidConfigValue, baseNode)\n      }\n\n      const configName = (expression.left as Identifier).name\n      const configValue = (expression.right as Literal).value\n\n      if (configName in this.currentConfig) {\n        this.baseNodeError(errors.configAlreadyDefined(configName), baseNode)\n      }\n\n      this.currentConfig[configName] = configValue\n\n      return {\n        ...emptyMetadata(),\n        config: {\n          [configName]: configValue,\n        },\n      }\n    }\n\n    if (baseNode.type === 'IfBlock' || baseNode.type === 'EachBlock') {\n      const expression = baseNode.expression\n      const conditionMetadata = await getLogicNodeMetadata({\n        node: expression,\n        supportedMethods: this.context.supportedMethods,\n      })\n\n      const elseMetadata = await this.getBaseNodeMetadata({\n        baseNode: baseNode.else,\n        depth: depth + 1,\n      })\n\n      const childrenMetadata = await Promise.all(\n        (baseNode.children || []).map((child) =>\n          this.getBaseNodeMetadata({\n            baseNode: child,\n            depth: depth + 1,\n          }),\n        ),\n      )\n\n      return mergeMetadata(conditionMetadata, elseMetadata, ...childrenMetadata)\n    }\n\n    if (baseNode.type === 'ElseBlock') {\n      const childrenMetadata = await Promise.all(\n        (baseNode.children || []).map((child) =>\n          this.getBaseNodeMetadata({\n            baseNode: child,\n            depth: depth + 1,\n          }),\n        ),\n      )\n      return mergeMetadata(...childrenMetadata)\n    }\n\n    throw this.baseNodeError(\n      errors.unsupportedBaseNodeType(baseNode.type),\n      baseNode,\n    )\n  }\n\n  private baseNodeError(\n    { code, message }: { code: string; message: string },\n    node: BaseNode,\n  ): never {\n    error(message, {\n      name: 'CompileError',\n      code,\n      source: this.context.sql || '',\n      start: node.start || 0,\n      end: node.end || undefined,\n    })\n  }\n\n  private expressionError(\n    { code, message }: { code: string; message: string },\n    node: Node,\n  ): never {\n    const source = (node.loc?.source ?? this.context.sql)!.split('\\n')\n    const start =\n      source\n        .slice(0, node.loc?.start.line! - 1)\n        .reduce((acc, line) => acc + line.length + 1, 0) +\n      node.loc?.start.column!\n    const end =\n      source\n        .slice(0, node.loc?.end.line! - 1)\n        .reduce((acc, line) => acc + line.length + 1, 0) + node.loc?.end.column!\n\n    error(message, {\n      name: 'CompileError',\n      code,\n      source: this.context.sql || '',\n      start,\n      end,\n    })\n  }\n}\n","import { Compiler } from './compiler'\nimport type {\n  QueryMetadata,\n  ResolveFn,\n  SupportedMethod,\n} from './compiler/types'\n\nexport type CompileParams = {\n  query: string\n  resolveFn: ResolveFn\n  supportedMethods?: Record<string, SupportedMethod>\n}\n\nexport function compile({\n  query,\n  supportedMethods,\n  resolveFn,\n}: CompileParams): Promise<string> {\n  return new Compiler({\n    sql: query,\n    supportedMethods: supportedMethods || {},\n    resolveFn,\n  }).compileSQL()\n}\n\nexport function readMetadata({\n  query,\n  supportedMethods,\n}: {\n  query: string\n  supportedMethods?: Record<string, SupportedMethod>\n}): Promise<QueryMetadata> {\n  return new Compiler({\n    sql: query,\n    supportedMethods: supportedMethods || {},\n    resolveFn: () => Promise.resolve(''),\n  }).readMetadata()\n}\n\nexport { default as CompileError } from './error/error'\nexport * from './compiler/types'\nexport * from './compiler/utils'\n"],"names":["PARSER_ERRORS","resolve","readMetadata","resolveArrayExpression","resolveAssignmentExpression","resolveBinaryExpression","resolveCallExpression","resolveChainExpression","resolveConditionalExpression","resolveIdentifier","resolveLiteral","resolveObjectExpression","resolveMemberExpression","resolveSequenceExpression","resolveUnaryExpression","resolveUpdateExpression","readArrayMetadata","readAssignmentMetadata","readBinaryMetadata","readCallMetadata","readChainMetadata","readConditionalMetadata","readObjectMetadata","readMemberMetadata","readSequenceMetadata","readUnaryMetadata","readUpdateMetadata"],"mappings":"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"}